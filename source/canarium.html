<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">/*
全モジュールのDEBUGレベルをセット
 */
var Canarium,
  slice = [].slice;

if (!Function.prototype.property) {

  /*
  Object.definePropertyによるプロパティ定義メソッド
   */
  Function.prototype.property = function(prop, desc) {
    return Object.defineProperty(this.prototype, prop, desc);
  };
}

if (!Function.Sequence) {

<span id='Function-Sequence'>  /**
</span>  @private
  @class
    非同期関数を用いたシーケンス実行クラス
   */
  Function.Sequence = (function() {

<span id='Function-Sequence-property-list'>    /**
</span>    @property {function(Function.Sequence)[]}
      シーケンスで実行する要素の関数リスト
    @readonly
     */
    Sequence.list = null;


<span id='Function-Sequence-property-onFinal'>    /**
</span>    @property {function(Function.Sequence)}
      シーケンス終了時に成功失敗にかかわらず呼び出される関数。
      finalメソッドでも設定可能。
     */

    Sequence.prototype.onFinal = null;


<span id='Function-Sequence-property-index'>    /**
</span>    @property {null/number}
      現在実行中の要素番号(シーケンス開始前はnull)
    @readonly
     */

    Sequence.prototype.index = null;


<span id='Function-Sequence-property-aborted'>    /**
</span>    @property {boolean}
      異常終了したかどうか
    @readonly
     */

    Sequence.prototype.aborted = false;


<span id='Function-Sequence-property-finished'>    /**
</span>    @property {boolean}
      正常終了したかどうか
    @readonly
     */

    Sequence.prototype.finished = false;


<span id='Function-Sequence-method-Sequence'>    /**
</span>    @method
      コンストラクタ
    @param {function(Function.Sequence)[]} list...
      初期状態で追加するシーケンス要素の関数リスト
     */

    function Sequence() {
      var list;
      list = 1 &lt;= arguments.length ? slice.call(arguments, 0) : [];
      this.list = list;
    }


<span id='Function-Sequence-method-add'>    /**
</span>    @method
      シーケンス要素を末尾に追加する
    @param {function(Function.Sequence)[]} f...
      追加するシーケンス要素の関数(複数可)
    @chainable
    @return {Function.Sequence} this
     */

    Sequence.prototype.add = function() {
      var f, ref;
      f = 1 &lt;= arguments.length ? slice.call(arguments, 0) : [];
      (ref = this.list).push.apply(ref, f);
      return this;
    };


<span id='Function-Sequence-method-final'>    /**
</span>    @method
      シーケンス終了時に成功失敗にかかわらず呼び出される関数を登録する
    @param {function(Function.Sequence)} f
      登録する関数
    @chainable
    @return {Function.Sequence} this
     */

    Sequence.prototype.final = function(f) {
      this.onFinal = f;
      return this;
    };


<span id='Function-Sequence-method-start'>    /**
</span>    @method
      シーケンスを開始する
    @return {void}
     */

    Sequence.prototype.start = function() {
      this.index = -1;
      this.aborted = false;
      this.finished = false;
      this.next(true);
    };


<span id='Function-Sequence-method-next'>    /**
</span>    @method
      シーケンスを一つ次へ進める(次が無ければ正常終了する)。または異常終了する。
    @param {boolean} [success]
      現在の要素が正常終了したかどうか(省略時true)。falseを指定するとシーケンスを異常終了する。
    @return {void}
     */

    Sequence.prototype.next = function(success) {
      if (this.aborted || this.finished || this.index === null) {
        return;
      }
      if (success === false) {
        this.aborted = true;
        if (typeof this.onFinal === &quot;function&quot;) {
          this.onFinal(this);
        }
        return;
      }
      this.index += 1;
      if (this.index &gt;= this.list.length) {
        this.finished = true;
        if (typeof this.onFinal === &quot;function&quot;) {
          this.onFinal(this);
        }
        return;
      }
      this.redo();
    };


<span id='Function-Sequence-method-redo'>    /**
</span>    @method
      シーケンスを次に進めずに、現在の要素をもう一度繰り返す。
    @return {void}
     */

    Sequence.prototype.redo = function() {
      if (this.aborted || this.finished || this.index === null) {
        return;
      }
      this.list[this.index].call(this, this);
    };


<span id='Function-Sequence-method-abort'>    /**
</span>    @method
      シーケンスを異常終了させる。next(false)に同じ。
    @return {void}
     */

    Sequence.prototype.abort = function() {
      this.next(false);
    };

    return Sequence;

  })();
}


/*
プレフィックス付き固定長16進数文字列への変換メソッド(デバッグ用)
 */

Number.prototype.hex = function(digits) {
  var s;
  s = this.toString(16);
  while (s.length &lt; digits) {
    s = &quot;0&quot; + s;
  }
  return &quot;0x&quot; + s;
};


/*
16進ダンプ(デバッグ用)
 */

Uint8Array.prototype.hexDump = function(maxLength) {
  var r, v;
  maxLength || (maxLength = this.length);
  r = (function() {
    var j, len1, ref, results;
    ref = this.subarray(0, maxLength);
    results = [];
    for (j = 0, len1 = ref.length; j &lt; len1; j++) {
      v = ref[j];
      results.push(v.hex(2));
    }
    return results;
  }).call(this);
  if (this.length &gt; maxLength) {
    r.push(&quot;...&quot;);
  }
  return &quot;[&quot; + (r.join(&quot;,&quot;)) + &quot;]&quot;;
};


<span id='Canarium'>/**
</span>@class Canarium
PERIDOTボードドライバ
 */

Canarium = (function() {
  var CONFIG_TIMEOUT_MS, DEBUG, EEPROM_SLAVE_ADDR;

  DEBUG = (DEBUG != null) || 0;


<span id='Canarium-property-version'>  /**
</span>  @property {string}
    ライブラリのバージョン
   */

  Canarium.prototype.version = &quot;0.9.9&quot;;


<span id='Canarium-property-boardInfo'>  /**
</span>  @property {Object}  boardInfo
    接続しているボードの情報
  
  @property {string}  boardInfo.id
    &#39;J72A&#39; (J-7SYSTEM Works / PERIDOT board)
  
  @property {string}  boardInfo.serialcode
    &#39;xxxxxx-yyyyyy-zzzzzz&#39;
   */

  Canarium.prototype.boardInfo = null;


<span id='Canarium-property-serialBitrate'>  /**
</span>  @property {number} serialBitrate
    デフォルトのビットレート({@link Canarium.BaseComm#bitrate}のアクセサとして定義)
   */

  Canarium.property(&quot;serialBitrate&quot;, {
    get: function() {
      return this._base.bitrate;
    },
    set: function(v) {
      return this._base.bitrate = v;
    }
  });


  /*
  @property {Canarium.Channel[]}
    チャネル[0～255]
  @readonly
   */

  Canarium.prototype.channels = null;


<span id='Canarium-property-i2c'>  /**
</span>  @property {Canarium.I2CComm}
    I2C通信制御クラスのインスタンス
  @readonly
   */

  Canarium.prototype.i2c = null;


<span id='Canarium-property-avs'>  /**
</span>  @property {Canarium.AvsPackets}
    Avalon-STパケット層通信クラスのインスタンス
  @readonly
   */

  Canarium.prototype.avs = null;


<span id='Canarium-property-avm'>  /**
</span>  @property {Canarium.AvmTransactions}
    Avalon-MMトランザクション層通信クラスのインスタンス
  @readonly
   */

  Canarium.prototype.avm = null;


<span id='Canarium-property-_base'>  /**
</span>  @private
  @property {Canarium.BaseComm}
    下位層通信クラスのインスタンス
   */

  Canarium.prototype._base = null;


<span id='Canarium-property-EEPROM_SLAVE_ADDR'>  /**
</span>  @private
  @property {number}
    EEPROMのスレーブアドレス(7-bit表記)
  @readonly
   */

  EEPROM_SLAVE_ADDR = 0x50;


<span id='Canarium-property-CONFIG_TIMEOUT_MS'>  /**
</span>  @private
  @property {number}
    コンフィグレーション開始のタイムアウト時間(ms)
  @readonly
   */

  CONFIG_TIMEOUT_MS = 3000;


<span id='Canarium-static-method-enumerate'>  /**
</span>  @static
  @method
  @inheritdoc Canarium.BaseComm#enumerate
  @localdoc
    {@link Canarium.BaseComm#enumerate}に転送されます
   */

  Canarium.enumerate = function() {
    var args, ref;
    args = 1 &lt;= arguments.length ? slice.call(arguments, 0) : [];
    return (ref = Canarium.BaseComm).enumerate.apply(ref, args);
  };


<span id='Canarium-method-Canarium'>  /**
</span>  @method
    コンストラクタ
   */

  function Canarium() {
    this._base = new Canarium.BaseComm();
    this.i2c = new Canarium.I2CComm(this._base);
    this.avs = new Canarium.AvsPackets(this._base);
    this.avm = new Canarium.AvmTransactions(this.avs);
  }


<span id='Canarium-method-open'>  /**
</span>  @inheritdoc Canarium.BaseComm#connect
   */

  Canarium.prototype.open = function(portname, callback) {
    if (this._base.connected) {
      callback(false);
      return;
    }
    this.boardInfo = null;
    new Function.Sequence((function(_this) {
      return function(seq) {
        return _this._base.connect(portname, function(result) {
          return seq.next(result);
        });
      };
    })(this), (function(_this) {
      return function(seq) {
        return _this._eepromRead(0x00, 4, function(result, readData) {
          var header;
          if (!result) {
            return seq.abort();
          }
          header = new Uint8Array(readData);
          if (header[0] === 0x4a &amp;&amp; header[1] === 0x37 &amp;&amp; header[2] === 0x57) {
            if (DEBUG &gt;= 1) {
              console.log(&quot;Canarium#connect::version(&quot; + header[3] + &quot;)&quot;);
            }
            _this.boardInfo = {
              version: header[3]
            };
            seq.next();
          }
          return seq.abort();
        });
      };
    })(this)).final((function(_this) {
      return function(seq) {
        if (seq.aborted) {
          return _this._base.disconnect(function() {
            return callback(false);
          });
        }
        return callback(true);
      };
    })(this)).start();
  };


<span id='Canarium-method-close'>  /**
</span>  @method
    PERIDOTデバイスポートのクローズ
  @param {function(boolean):void} callback
    コールバック関数
  @return {void}
   */

  Canarium.prototype.close = function(callback) {
    if (!this._base.connected) {
      callback(false);
      return;
    }
    this._base.disconnect((function(_this) {
      return function(result) {
        _this.boardInfo = null;
        return callback(result);
      };
    })(this));
  };


<span id='Canarium-method-config'>  /**
</span>  @method
    ボードのFPGAコンフィグレーション
  @param {Object/null}  boardInfo
    ボード情報(ボードIDやシリアル番号を限定したい場合)
  @param {string/null}  boardInfo.id
    ボードID
  @param {string/null}  boardInfo.serialCode
    シリアル番号
  @param {ArrayBuffer}  rbfdata
    rbfまたはrpdのデータ
  @param {function(boolean):void} callback
    コールバック関数
  @return {void}
   */

  Canarium.prototype.config = function(boardInfo, rbfdata, callback) {
    var seq, startTime;
    if (!this._base.connected) {
      return callback(false);
    }
    startTime = null;
    seq = new Function.Sequence();
    if (boardInfo) {
      if (!(this.boardInfo.id &amp;&amp; this.boardInfo.serialcode)) {
        seq.add((function(_this) {
          return function() {
            return _this.getinfo(function(result) {
              return seq.next(result);
            });
          };
        })(this));
      }
      seq.add((function(_this) {
        return function() {
          var mismatch;
          mismatch = function(a, b) {
            return a &amp;&amp; a !== b;
          };
          if (mismatch(boardInfo.id, _this.boardInfo.id)) {
            return seq.abort();
          }
          if (mismatch(boardInfo.serialcode, _this.boardInfo.serialcode)) {
            return seq.abort();
          }
          return seq.next();
        };
      })(this));
    }
    seq.add((function(_this) {
      return function() {
        return _this._base.transCommand(0x3b, function(result, response) {
          if (!result) {
            return seq.abort();
          }
          if ((response &amp; 0x01) === 0x00) {
            return seq.next();
          }
          return seq.abort();
        });
      };
    })(this));
    seq.add(function() {
      startTime = window.performance.now();
      return seq.next();
    });
    seq.add((function(_this) {
      return function() {
        return _this._base.transCommand(0x32, function(result, response) {
          var dulation;
          if (!result) {
            return seq.abort();
          }
          if ((response &amp; 0x06) === 0x00) {
            return seq.next();
          }
          dulation = parseInt(window.performance.now() - startTime);
          if (dulation &gt; CONFIG_TIMEOUT_MS) {
            return seq.abort();
          }
          return seq.redo();
        });
      };
    })(this));
    seq.add((function(_this) {
      return function() {
        return _this._base.transCommand(0x33, function(result, response) {
          var dulation;
          if (!result) {
            return seq.abort();
          }
          if ((response &amp; 0x06) === 0x02) {
            return seq.next();
          }
          dulation = parseInt(window.performance.now() - startTime);
          if (dulation &gt; CONFIG_TIMEOUT_MS) {
            return seq.abort();
          }
          return seq.redo();
        });
      };
    })(this));
    seq.add((function(_this) {
      return function() {
        return _this._base.transData(rbfdata, 0, function(result) {
          return seq.next(result);
        });
      };
    })(this));
    seq.add((function(_this) {
      return function() {
        return _this._base.transCommand(0x33, function(result, response) {
          if (!result) {
            return seq.abort();
          }
          if ((response &amp; 0x06) === 0x06) {
            return seq.next();
          }
          return seq.abort();
        });
      };
    })(this));
    seq.add((function(_this) {
      return function() {
        return _this._base.transCommand(0x39, function(result, response) {
          return seq.next(result);
        });
      };
    })(this));
    seq.final(function() {
      if (seq.aborted) {
        return callback(false);
      }
    }).start();
  };


<span id='Canarium-method-reset'>  /**
</span>  @method
    ボードのマニュアルリセット
  @param {function(boolean):void} callback
    コールバック関数
  @return {void}
   */

  Canarium.prototype.reset = function(callback) {
    if (!this._base.connected) {
      return callback(false);
    }
    new Function.Sequence((function(_this) {
      return function(seq) {
        return _this._base.transCommand(0x31, function(result, response) {
          if (!result) {
            return seq.abort();
          }
          return window.setTimeout((function() {
            return seq.next();
          }), 100);
        });
      };
    })(this), (function(_this) {
      return function(seq) {
        return _this._base.transCommand(0x39, function(result, response) {
          if (!result) {
            return seq.abort();
          }
          return seq.next();
        });
      };
    })(this)).final(function(seq) {
      return callback(seq.finished);
    }).start();
  };


<span id='Canarium-method-getinfo'>  /**
</span>  @method
    ボード情報の取得
  @param {function(boolean):void} callback
    コールバック関数
  @return {void}
   */

  Canarium.prototype.getinfo = function(callback) {
    var ref, seq;
    if (!(this._base.connected &amp;&amp; ((ref = this.boardInfo) != null ? ref.version : void 0))) {
      console.log(this._base);
      console.log(this.boardInfo);
      callback(false);
      return;
    }
    seq = new Function.Sequence();
    switch (this.boardInfo.version) {
      case 1:
        seq.add((function(_this) {
          return function(seq) {
            return _this._eepromRead(0x04, 8, function(result, readData) {
              var info, mid, pid, s, sid;
              if (!result) {
                return seq.abort();
              }
              info = new Uint8Array(readData);
              if (DEBUG &gt;= 2) {
                console.log(&quot;getinfo::ver1::read(&quot; + (info.hexDump()) + &quot;)&quot;);
              }
              mid = (info[0] &lt;&lt; 8) | (info[1] &lt;&lt; 0);
              pid = (info[2] &lt;&lt; 8) | (info[3] &lt;&lt; 0);
              sid = (info[4] &lt;&lt; 24) | (info[5] &lt;&lt; 16) | (info[6] &lt;&lt; 8) | (info[7] &lt;&lt; 0);
              if (mid === 0x0072) {
                s = &quot;&quot; + (pid.hex(4)) + (sid.hex(8));
                _this.boardInfo.id = &quot;J72A&quot;;
                _this.boardInfo.serialcode = (s.substr(0, 6)) + &quot;-&quot; + (s.substr(6, 6)) + &quot;-000000&quot;;
              }
              return seq.next();
            });
          };
        })(this));
        break;
      case 2:
        seq.add((function(_this) {
          return function(seq) {
            return _this._eepromRead(0x04, 22, function(result, readData) {
              var bid, i, info, j, k, s;
              if (!result) {
                return seq.abort();
              }
              info = new Uint8Array(readData);
              if (DEBUG &gt;= 2) {
                console.log(&quot;getinfo::ver2::read(&quot; + (info.hexDump()) + &quot;)&quot;);
              }
              bid = &quot;&quot;;
              for (i = j = 0; j &lt; 4; i = ++j) {
                bid += String.fromCharCode(info[i]);
              }
              s = &quot;&quot;;
              for (i = k = 4; k &lt; 22; i = ++k) {
                s += String.fromCharCode(info[i]);
              }
              _this.boardInfo.id = bid;
              _this.boardInfo.serialcode = (s.substr(0, 6)) + &quot;-&quot; + (s.substr(6, 6)) + &quot;-&quot; + (s.substr(12, 6));
              return seq.next();
            });
          };
        })(this));
        break;
      default:
        if (DEBUG &gt;= 1) {
          console.log(&quot;getinfo::unknown_version&quot;);
        }
        callback(false);
        return;
    }
    seq.final(function(seq) {
      return callback(seq.finished);
    }).start();
  };


<span id='Canarium-method-_eepromRead'>  /**
</span>  @private
  @method
    EEPROMの読み出し
  @param {number} startaddr
    読み出し開始アドレス
  @param {number} readbytes
    読み出しバイト数
  @param {function(boolean,ArrayBuffer)} callback
    コールバック関数
   */

  Canarium.prototype._eepromRead = function(startaddr, readbytes, callback) {
    var array, index;
    array = new Uint8Array(readbytes);
    index = -1;
    return new Function.Sequence((function(_this) {
      return function(seq) {
        return _this.i2c.start(function(result) {
          return seq.next(result);
        });
      };
    })(this), (function(_this) {
      return function(seq) {
        return _this.i2c.write(EEPROM_SLAVE_ADDR &lt;&lt; 1, function(result, ack) {
          return seq.next(result &amp;&amp; ack);
        });
      };
    })(this), (function(_this) {
      return function(seq) {
        return _this.i2c.write(startaddr &amp; 0xff, function(result, ack) {
          return seq.next(result &amp;&amp; ack);
        });
      };
    })(this), (function(_this) {
      return function(seq) {
        return _this.i2c.start(function(result) {
          return seq.next(result);
        });
      };
    })(this), (function(_this) {
      return function(seq) {
        return _this.i2c.write((EEPROM_SLAVE_ADDR &lt;&lt; 1) + 1, function(result, ack) {
          return seq.next(result &amp;&amp; ack);
        });
      };
    })(this), (function(_this) {
      return function(seq) {
        if (readbytes === 0) {
          return seq.next();
        }
        return _this.i2c.read(readbytes &gt; 1, function(result, readdata) {
          if (!result) {
            return seq.abort();
          }
          array[index += 1] = readdata;
          readbytes -= 1;
          return seq.redo();
        });
      };
    })(this)).final((function(_this) {
      return function(seq) {
        return _this.i2c.stop(function(result) {
          if (seq.aborted || !result) {
            return callback(false, null);
          }
          return callback(true, array.buffer);
        });
      };
    })(this)).start();
  };


<span id='Canarium-method-_err'>  /**
</span>  @method
    開発者向けのエラーログを出力する
  @param {Object} data
    出力メッセージ等のデータ(型は自由)
  @return {void}
  @private
   */

  Canarium.prototype._err = function(data) {
    console.log({
      &quot;error&quot;: data,
      &quot;stack&quot;: new Error().stack,
      &quot;canarium&quot;: this
    });
  };

  return Canarium;

})();


<span id='Canarium-BaseComm'>/**
</span>@class Canarium.BaseComm
PERIDOTボード下位層通信クラス
@uses chrome.serial
 */

Canarium.BaseComm = (function() {
  var DEBUG, SPLIT_EVENT_CONTEXT;

  DEBUG = (DEBUG != null) || 0;


<span id='Canarium-BaseComm-property-connected'>  /**
</span>  @property {boolean}
    接続状態(true:接続済み, false:未接続)
   */

  BaseComm.prototype.connected = false;


<span id='Canarium-BaseComm-property-path'>  /**
</span>  @property {string}
    接続しているシリアル通信デバイスのパス
   */

  BaseComm.prototype.path = null;


<span id='Canarium-BaseComm-property-bitrate'>  /**
</span>  @property {number}
    ビットレート(bps)
   */

  BaseComm.prototype.bitrate = 115200;


<span id='Canarium-BaseComm-property-_cid'>  /**
</span>  @private
  @property {number}
    シリアル接続ID
   */

  BaseComm.prototype._cid = null;


<span id='Canarium-BaseComm-property-_onReceive'>  /**
</span>  @private
  @property {Function}
    受信コールバック関数(thisバインド付きの関数オブジェクト)
   */

  BaseComm.prototype._onReceive = null;


<span id='Canarium-BaseComm-property-_onReceiveError'>  /**
</span>  @private
  @property {Function}
    受信エラーコールバック関数(thisバインド付きの関数オブジェクト)
   */

  BaseComm.prototype._onReceiveError = null;


<span id='Canarium-BaseComm-property-_rxQueue'>  /**
</span>  @private
  @property {Object[]}
    受信待ちキュー
   */

  BaseComm.prototype._rxQueue = null;


<span id='Canarium-BaseComm-property-_rxBuffers'>  /**
</span>  @private
  @property {ArrayBuffer[]}
    受信データバッファの配列
   */

  BaseComm.prototype._rxBuffers = null;


<span id='Canarium-BaseComm-property-_rxTotalLength'>  /**
</span>  @private
  @property {number}
    受信データの合計サイズ
   */

  BaseComm.prototype._rxTotalLength = null;


<span id='Canarium-BaseComm-property-SPLIT_EVENT_CONTEXT'>  /**
</span>  @private
  @property {boolean}
    chrome.serialのイベントハンドラのコンテキストから分離するか否か(デバッグ用)
  @readonly
   */

  SPLIT_EVENT_CONTEXT = false;


<span id='Canarium-BaseComm-static-method-enumerate'>  /**
</span>  @static
  @method
    接続対象デバイスを列挙する
    (PERIDOTでないデバイスも列挙される可能性があることに注意)
  @param {function(boolean,Object[]):void}  callback
    コールバック関数(配列の各要素は次のメンバを持つ)
  
    - name : UI向け名称(COMxxなど)
    - path : 内部管理向けパス
  @return {void}
   */

  BaseComm.enumerate = function(callback) {
    chrome.serial.getDevices(function(ports) {
      var devices, j, len1, port;
      devices = [];
      for (j = 0, len1 = ports.length; j &lt; len1; j++) {
        port = ports[j];
        devices.push({
          path: &quot;&quot; + port.path,
          name: &quot;&quot; + (port.displayName || port.path)
        });
      }
      return callback(true, devices);
    });
  };


<span id='Canarium-BaseComm-method-BaseComm'>  /**
</span>  @method
    コンストラクタ
   */

  function BaseComm() {
    this._onReceive = (function(_this) {
      return function(info) {
        return _this._onReceiveHandler(info);
      };
    })(this);
    this._onReceiveError = (function(_this) {
      return function(info) {
        return _this._onReceiveErrorHandler(info);
      };
    })(this);
  }


<span id='Canarium-BaseComm-method-connect'>  /**
</span>  @method
    ボードに接続する
  @param {string} path
    接続先パス(enumerateが返すpath)
  @param {function(boolean):void} callback
    コールバック関数
  @return {void}
   */

  BaseComm.prototype.connect = function(path, callback) {
    if (this.connected) {
      callback(false);
      return;
    }
    this.connected = true;
    this.path = null;
    chrome.serial.connect(path, {
      bitrate: this.bitrate
    }, (function(_this) {
      return function(connectionInfo) {

        /*
        Windows: 接続失敗時はundefinedでcallbackが呼ばれる @ chrome47
         */
        if (!connectionInfo) {
          chrome.runtime.lastError;
          _this.connected = false;
          return callback(false);
        }
        _this.path = &quot;&quot; + path;
        _this._cid = connectionInfo.connectionId;
        _this._rxQueue = [];
        _this._rxBuffers = [];
        _this._rxTotalLength = 0;
        chrome.serial.onReceive.addListener(_this._onReceive);
        chrome.serial.onReceiveError.addListener(_this._onReceiveError);
        return callback(true);
      };
    })(this));
  };


<span id='Canarium-BaseComm-method-disconnect'>  /**
</span>  @method
    ボードから切断する
  @param {function(boolean):void} callback
    コールバック関数
  @return {void}
   */

  BaseComm.prototype.disconnect = function(callback) {
    if (!this.connected) {
      callback(false);
      return;
    }
    chrome.serial.disconnect(this._cid, (function(_this) {
      return function(result) {
        if (!result) {
          return callback(false);
        }
        chrome.serial.onReceive.removeListener(_this._onReceive);
        chrome.serial.onReceiveError.removeListener(_this._onReceiveError);
        _this.connected = false;
        _this.path = null;
        _this._cid = null;
        _this._rxQueue = null;
        _this._rxBuffers = null;
        _this._rxTotalLength = null;
        return callback(true);
      };
    })(this));
  };


<span id='Canarium-BaseComm-method-transCommand'>  /**
</span>  @method
    制御コマンドの送受信を行う
  @param {number} command
    コマンドバイト
  @param {function(boolean,number):void}  callback
    コールバック関数
  @return {void}
   */

  BaseComm.prototype.transCommand = function(command, callback) {
    var txarray;
    txarray = new Uint8Array(2);
    txarray[0] = 0x3a;
    txarray[1] = command;
    this._transSerial(txarray.buffer, 1, function(result, rxdata) {
      var rxArray;
      if (!result) {
        return callback(false, null);
      }
      rxArray = new Uint8Array(rxdata);
      return callback(true, rxArray[0]);
    });
  };


<span id='Canarium-BaseComm-method-transData'>  /**
</span>  @method
    データの送受信を行う
  @param {ArrayBuffer/null} txdata
    送信するデータ(制御バイトは自動的にエスケープされる。nullの場合は受信のみ)
  @param {number} rxsize
    受信するバイト数
  @param {function(boolean,ArrayBuffer):void} callback
    コールバック関数
  @return {void}
   */

  BaseComm.prototype.transData = function(txdata, rxsize, callback) {
    var byte, dst, j, len, len1, src;
    if (txdata) {
      src = new Uint8Array(txdata);
      dst = new Uint8Array(txdata.byteLength * 2);
      len = 0;
      for (j = 0, len1 = src.length; j &lt; len1; j++) {
        byte = src[j];
        if (byte === 0x3a || byte === 0x3d) {
          dst[len] = 0x3d;
          len += 1;
          byte ^= 0x20;
        }
        dst[len] = byte;
        len += 1;
      }
      txdata = dst.buffer.slice(0, len);
    }
    this._transSerial(txdata, rxsize, callback);
  };


<span id='Canarium-BaseComm-method-_transSerial'>  /**
</span>  @private
  @method
    シリアル通信の送受信を行う
  @param {ArrayBuffer/null} txdata
    送信するデータ(nullの場合は受信のみ)
  @param {number} rxsize
    受信するバイト数
  @param {function(boolean,ArrayBuffer):void} callback
    コールバック関数
  @return {void}
   */

  BaseComm.prototype._transSerial = function(txdata, rxsize, callback) {
    if (!this.connected) {
      callback(false, null);
      return;
    }
    this._rxQueue.push({
      length: rxsize,
      callback: callback
    });
    if (!txdata) {
      return;
    }
    if (DEBUG &gt;= 1) {
      console.log({
        &quot;BaseComm::(send)&quot;: new Uint8Array(txdata).hexDump()
      });
    }
    chrome.serial.send(this._cid, txdata, function() {
      return null;
    });
  };


<span id='Canarium-BaseComm-method-_onReceiveHandler'>  /**
</span>  @private
  @method
    シリアル受信時の処理を行う
  @param {Object} info
    受信情報
  @param {number} info.connectionId
    接続ID
  @param {ArrayBuffer} info.data
    受信データ
  @return {void}
   */

  BaseComm.prototype._onReceiveHandler = function(info) {
    if (!(info.connectionId === this._cid &amp;&amp; this.connected)) {
      return;
    }
    this._addRxBuffer(info.data);
    if (SPLIT_EVENT_CONTEXT) {
      window.setTimeout(((function(_this) {
        return function() {
          return _this._onReceiveHandler2();
        };
      })(this)), 0);
    } else {
      this._onReceiveHandler2();
    }
  };

  BaseComm.prototype._onReceiveHandler2 = function() {
    var buffer, length, queue;
    while (this._rxQueue.length &gt; 0) {
      length = this._rxQueue[0].length;
      if (length &gt; this._rxTotalLength) {
        break;
      }
      queue = this._rxQueue.shift();
      buffer = this._sliceRxBuffer(length);
      if (DEBUG &gt;= 1) {
        console.log({
          &quot;BaseComm::(recv)&quot;: new Uint8Array(buffer).hexDump()
        });
      }
      queue.callback.call(void 0, true, buffer);
    }
  };


<span id='Canarium-BaseComm-method-_addRxBuffer'>  /**
</span>  @private
  @method
    受信データバッファの末尾にデータを追加する
  @param {ArrayBuffer} data
    受信データ
  @return {void}
   */

  BaseComm.prototype._addRxBuffer = function(data) {
    this._rxBuffers.push(data.slice(0));
    this._rxTotalLength += data.byteLength;
  };


<span id='Canarium-BaseComm-method-_sliceRxBuffer'>  /**
</span>  @private
  @method
    受信データバッファの先頭からデータを取り出す
  @param {number} length
    取り出すバイト数
  @return {ArrayBuffer/null}
    取り出したデータ(バッファ不足時はnull)
   */

  BaseComm.prototype._sliceRxBuffer = function(length) {
    var array, partBuf, partLen, pos, rem;
    if (length &gt; this._rxTotalLength) {
      return null;
    }
    array = new Uint8Array(length);
    pos = 0;
    rem = length;
    while (rem &gt; 0) {
      partBuf = this._rxBuffers[0];
      partLen = partBuf.byteLength;
      if (partLen &lt;= rem) {
        this._rxBuffers.shift();
      } else {
        array = new Uint8Array(partLen - rem);
        array.set(new Uint8Array(partBuf, rem));
        this._rxBuffers[0] = array.buffer;
        partLen = rem;
      }
      array.set(new Uint8Array(partBuf, 0, partLen), pos);
      pos += partLen;
      rem -= partLen;
    }
    this._rxTotalLength -= length;
    return array.buffer;
  };


<span id='Canarium-BaseComm-method-_onReceiveErrorHandler'>  /**
</span>  @private
  @method
    受信エラーハンドラ
  @param {Object} info
    エラー情報
  @param {number} info.connectionId
    接続ID
  @param {&quot;disconnected&quot;/&quot;timeout&quot;/&quot;device_lost&quot;/&quot;break&quot;/
          &quot;frame_error&quot;/&quot;overrun&quot;/&quot;buffer_overflow&quot;/
          &quot;parity_error&quot;/&quot;system_error&quot;} info.error
    エラー種別を示す文字列
  @return {void}
   */

  BaseComm.prototype._onReceiveErrorHandler = function(info) {
    if (!(info.connectionId === this._cid &amp;&amp; this.connected)) {
      return;
    }
    if (SPLIT_EVENT_CONTEXT) {
      window.setTimeout(((function(_this) {
        return function() {
          return _this._onReceiveErrorHandler2();
        };
      })(this)), 0);
    } else {
      this._onReceiveErrorHandler2();
    }
  };

  BaseComm.prototype._onReceiveErrorHandler2 = function() {
    var queue;
    this.disconnect(function() {});
    this._rxBuffers = [];
    this._rxTotalLength = 0;
    while (queue = this._rxQueue.shift()) {
      queue.callback.call(void 0, false, null);
    }
  };

  return BaseComm;

})();


<span id='Canarium-I2CComm'>/**
</span>@class Canarium.I2CComm
PERIDOTボードI2C通信クラス
@uses Canarium.BaseComm
 */

Canarium.I2CComm = (function() {
  var DEBUG, I2C_TIMEOUT_MS, _tryActions;

  DEBUG = (DEBUG != null) || 0;


<span id='Canarium-I2CComm-property-_base'>  /**
</span>  @private
  @property {Canarium.BaseComm}
    下位層通信クラスのインスタンス
   */

  I2CComm.prototype._base = null;


<span id='Canarium-I2CComm-property-I2C_TIMEOUT_MS'>  /**
</span>  @private
  @property {number}
    I2C通信のタイムアウト時間
  @readonly
   */

  I2C_TIMEOUT_MS = 100;


<span id='Canarium-I2CComm-method-I2CComm'>  /**
</span>  @method
    コンストラクタ
  @param {Canarium.BaseComm} _base
    下位層通信クラスのインスタンス
   */

  function I2CComm(_base) {
    this._base = _base;
  }


<span id='Canarium-I2CComm-method-start'>  /**
</span>  @method
    スタートコンディションの送信
  @param {function(boolean):void} callback
    コールバック関数
  @return {void}
   */

  I2CComm.prototype.start = function(callback) {
    var sclLow, sdaLow, setup;
    if (DEBUG &gt;= 1) {
      console.log(&quot;i2c::start&quot;);
    }
    setup = (function(_this) {
      return function(done, abort, retry) {
        if (DEBUG &gt;= 2) {
          console.log(&quot;i2c::start::setup&quot;);
        }
        return _this._base.transCommand(0x3b, function(result, response) {
          if (!result) {
            return abort(false);
          }
          if ((response &amp; 0x30) !== 0x30) {
            return retry();
          }
          return done(true);
        });
      };
    })(this);
    sdaLow = (function(_this) {
      return function(done, abort, retry) {
        if (DEBUG &gt;= 2) {
          console.log(&quot;i2c::start::sdaLow&quot;);
        }
        return _this._base.transCommand(0x1b, function(result, response) {
          if (!result) {
            return abort(false);
          }
          return done(true);
        });
      };
    })(this);
    sclLow = (function(_this) {
      return function(done, abort, retry) {
        if (DEBUG &gt;= 2) {
          console.log(&quot;i2c::start::sclLow&quot;);
        }
        return _this._base.transCommand(0x0b, function(result, response) {
          if (!result) {
            return abort(false);
          }
          return done(true);
        });
      };
    })(this);
    _tryActions([setup, sdaLow, sclLow], callback, I2C_TIMEOUT_MS);
  };


<span id='Canarium-I2CComm-method-stop'>  /**
</span>  @method
    ストップコンディションの送信
    (必ずSCL=&#39;L&#39;が先行しているものとする)
  @param {function(boolean):void} callback
    コールバック関数
  @return {void}
   */

  I2CComm.prototype.stop = function(callback) {
    var sclRelease, sdaRelease, setup;
    if (DEBUG &gt;= 1) {
      console.log(&quot;i2c::stop&quot;);
    }
    setup = (function(_this) {
      return function(done, abort, retry) {
        if (DEBUG &gt;= 2) {
          console.log(&quot;i2c::stop::setup&quot;);
        }
        return _this._base.transCommand(0x0b, function(result, response) {
          if (!result) {
            return abort(false);
          }
          return done(true);
        });
      };
    })(this);
    sclRelease = (function(_this) {
      return function(done, abort, retry) {
        if (DEBUG &gt;= 2) {
          console.log(&quot;i2c::stop::sclRelease&quot;);
        }
        return _this._base.transCommand(0x1b, function(result, response) {
          if (!result) {
            return abort(false);
          }
          if ((response &amp; 0x30) !== 0x10) {
            return retry();
          }
          return done(true);
        });
      };
    })(this);
    sdaRelease = (function(_this) {
      return function(done, abort, retry) {
        if (DEBUG &gt;= 2) {
          console.log(&quot;i2c::stop::sdaRelease&quot;);
        }
        return _this._base.transCommand(0x3b, function(result, response) {
          if (!result) {
            return abort(false);
          }
          if ((response &amp; 0x30) !== 0x30) {
            return retry();
          }
          return done(true);
        });
      };
    })(this);
    _tryActions([setup, sclRelease, sdaRelease], callback, I2C_TIMEOUT_MS);
  };


<span id='Canarium-I2CComm-method-read'>  /**
</span>  @method
    バイトリード
    (必ずSCL=&#39;L&#39;が先行しているものとする)
  @param {boolean}  ack
    ACK返却の有無(true:ACK, false:NAK)
  @param {function(boolean, Number):void} callback
    コールバック関数
    function(boolean:通信成否, Number:読み込みデータ(0～255))
  @return {void}
   */

  I2CComm.prototype.read = function(ack, callback) {
    var bitNum, readBits, readData, sendAck;
    if (DEBUG &gt;= 1) {
      console.log(&quot;i2c::read&quot;);
    }
    bitNum = 8;
    readData = 0x00;
    readBits = (function(_this) {
      return function(done, abort, retry) {
        bitNum -= 1;
        if (DEBUG &gt;= 2) {
          console.log(&quot;i2c::read::readBits[&quot; + bitNum + &quot;]&quot;);
        }
        return _this._readBit(function(result, bit) {
          if (!result) {
            return abort(false);
          }
          readData = (readData &lt;&lt; 1) | bit;
          return done(true);
        });
      };
    })(this);
    sendAck = (function(_this) {
      return function(done, abort, retry) {
        if (DEBUG &gt;= 2) {
          console.log(&quot;i2c::read::sendAck&quot;);
        }
        return _this._writeBit((ack ? 0 : 1), function(result) {
          if (!result) {
            return abort(false);
          }
          return done(true);
        });
      };
    })(this);
    _tryActions(((function() {
      var j, results;
      results = [];
      for (j = 7; j &gt;= 0; j--) {
        results.push(readBits);
      }
      return results;
    })()).concat(sendAck), function(result) {
      return callback(result, result ? readData : null);
    }, I2C_TIMEOUT_MS);
  };


<span id='Canarium-I2CComm-method-write'>  /**
</span>  @method
    バイトライト
    (必ずSCL=&#39;L&#39;が先行しているものとする)
  @param {number} writebyte
    書き込むデータ(0～255)
  @param {function(boolean, boolean):void} callback
    コールバック関数
    function(boolean:通信成否, boolean:ACK受信有無)
  @return {void}
   */

  I2CComm.prototype.write = function(writebyte, callback) {
    var bitNum, recvAck, writeBits, writeData;
    if (DEBUG &gt;= 1) {
      console.log(&quot;i2c::write(&quot; + (writebyte.hex(2)) + &quot;)&quot;);
    }
    bitNum = 8;
    writeData = 0 + writebyte;
    writeBits = (function(_this) {
      return function(done, abort, retry) {
        var bit;
        bitNum -= 1;
        bit = (writeData &gt;&gt;&gt; 7) &amp; 1;
        writeData &lt;&lt;= 1;
        if (DEBUG &gt;= 2) {
          console.log(&quot;i2c::write::writeBits[&quot; + bitNum + &quot;]&quot;);
        }
        return _this._writeBit(bit, function(result) {
          if (!result) {
            return abort(false);
          }
          return done(true);
        });
      };
    })(this);
    recvAck = (function(_this) {
      return function(done, abort, retry) {
        if (DEBUG &gt;= 2) {
          console.log(&quot;i2c::write::recvAck&quot;);
        }
        return _this._readBit(function(result, bit) {
          if (!result) {
            return abort(false);
          }
          return done(true, bit);
        });
      };
    })(this);
    _tryActions(((function() {
      var j, results;
      results = [];
      for (j = 7; j &gt;= 0; j--) {
        results.push(writeBits);
      }
      return results;
    })()).concat(recvAck), function(result, ack_n) {
      return callback(result, result ? ack_n === 0 : null);
    }, I2C_TIMEOUT_MS);
  };


<span id='Canarium-I2CComm-method-_readBit'>  /**
</span>  @private
  @method
    1ビットリード
    (必ずSCL=&#39;L&#39;が先行しているものとする)
  @param {function(boolean,number)} callback
    コールバック関数
   */

  I2CComm.prototype._readBit = function(callback) {
    var bit, sclLow, setup;
    if (DEBUG &gt;= 2) {
      console.log(&quot;i2c::_readBit&quot;);
    }
    bit = 0;
    setup = (function(_this) {
      return function(done, abort, retry) {
        if (DEBUG &gt;= 3) {
          console.log(&quot;i2c::_readBit::setup&quot;);
        }
        return _this._base.transCommand(0x3b, function(result, response) {
          if (!result) {
            return abort(false);
          }
          if ((response &amp; 0x10) !== 0x10) {
            return retry();
          }
          if ((response &amp; 0x20) === 0x20) {
            bit = 1;
          }
          return done(true);
        });
      };
    })(this);
    sclLow = (function(_this) {
      return function(done, abort, retry) {
        if (DEBUG &gt;= 3) {
          console.log(&quot;i2c::_readBit::sclLow&quot;);
        }
        return _this._base.transCommand(0x2b, function(result, response) {
          if (!result) {
            return abort(false);
          }
          return done(true);
        });
      };
    })(this);
    _tryActions([setup, sclLow], function(result) {
      if (DEBUG &gt;= 2) {
        console.log(&quot;=&gt; &quot; + (result ? bit : &quot;(failed)&quot;));
      }
      return callback(result, result ? bit : null);
    }, I2C_TIMEOUT_MS);
  };


<span id='Canarium-I2CComm-method-_writeBit'>  /**
</span>  @private
  @method
    1ビットライト
    (必ずSCL=&#39;L&#39;が先行しているものとする)
  @param {0/1}  bit
  @param {function(boolean)}  callback
    コールバック関数
   */

  I2CComm.prototype._writeBit = function(bit, callback) {
    var sclLow, sclRelease, setup;
    if (DEBUG &gt;= 2) {
      console.log(&quot;i2c::_writeBit(&quot; + bit + &quot;)&quot;);
    }
    setup = (function(_this) {
      return function(done, abort, retry) {
        if (DEBUG &gt;= 3) {
          console.log(&quot;i2c::_writeBit::setup&quot;);
        }
        return _this._base.transCommand(0x0b + ((bit &amp; 1) &lt;&lt; 5), function(result, response) {
          if (!result) {
            return abort(false);
          }
          return done(true);
        });
      };
    })(this);
    sclRelease = (function(_this) {
      return function(done, abort, retry) {
        if (DEBUG &gt;= 3) {
          console.log(&quot;i2c::_writeBit::sclRelease&quot;);
        }
        return _this._base.transCommand(0x1b + ((bit &amp; 1) &lt;&lt; 5), function(result, response) {
          if (!result) {
            return abort(false);
          }
          if ((response &amp; 0x10) !== 0x10) {
            return retry();
          }
          return done(true);
        });
      };
    })(this);
    sclLow = (function(_this) {
      return function(done, abort, retry) {
        if (DEBUG &gt;= 3) {
          console.log(&quot;i2c::_writeBit::sclLow&quot;);
        }
        return _this._base.transCommand(0x2b, function(result, response) {
          if (!result) {
            return abort(false);
          }
          return done(true);
        });
      };
    })(this);
    _tryActions([setup, sclRelease, sclLow], callback, I2C_TIMEOUT_MS);
  };


<span id='Canarium-I2CComm-static-method-_tryActions'>  /**
</span>  @static
  @private
  @method
    タイムアウト付きで非同期アクション(複数可)を試行する
  @param {Function[]} actions
    実行するアクションの配列(完了,中止,リトライの3つのコールバック関数を引数とする)
  @param {function(boolean)} callback
    すべてのアクションが完了したときのコールバック関数
  @param {number} timeout
    1アクション当たりのタイムアウト時間
    (window.performance.nowにより経過時間で計測される)
  @param {number} [period]
    リトライ周期(省略時は0ms…最小待ち)
  @return {void}
   */

  _tryActions = function(actions, callback, timeout, period) {
    var abort, action, done, retry, start, startTime;
    if (!(actions instanceof Array)) {
      actions = [actions];
    }
    period || (period = 0);
    action = 0;
    startTime = window.performance.now();
    done = function() {
      var args;
      args = 1 &lt;= arguments.length ? slice.call(arguments, 0) : [];
      action += 1;
      if (action &lt; actions.length) {
        return start();
      }
      return callback.apply(null, args);
    };
    abort = function() {
      var args;
      args = 1 &lt;= arguments.length ? slice.call(arguments, 0) : [];
      return callback.apply(null, args);
    };
    retry = function() {
      var elapsed;
      elapsed = window.performance.now() - startTime;
      console.log(&quot;timeout!&quot;);
      if (elapsed &gt; timeout) {
        return abort();
      }
      return window.setTimeout(start, period);
    };
    start = (function(_this) {
      return function() {
        return actions[action](done, retry, abort);
      };
    })(this);
    start();
  };

  return I2CComm;

})();


<span id='Canarium-AvsPackets'>/**
</span>@class Canarium.AvsPackets
PERIDOTボードAvalon-STパケット層通信クラス
@uses Canarium.BaseComm
 */

Canarium.AvsPackets = (function() {
  var DEBUG;

  DEBUG = (DEBUG != null) || 0;


<span id='Canarium-AvsPackets-property-_base'>  /**
</span>  @private
  @property {Canarium.BaseComm}
    下位層通信クラスのインスタンス
   */

  AvsPackets.prototype._base = null;


<span id='Canarium-AvsPackets-method-AvsPackets'>  /**
</span>  @method
    コンストラクタ
  @param {Canarium.BaseComm} _base
    下位層通信クラスのインスタンス
   */

  function AvsPackets(_base) {
    this._base = _base;
  }


<span id='Canarium-AvsPackets-method-transPacket'>  /**
</span>  @method
    Avalon-STパケットを送受信する。
    チャネル選択およびSOP/EOPは自動的に付加される。
    現時点では、受信データに複数のチャネルがインタリーブすることは認めない。
  @param {number} channel
    チャネル番号(0～255)
  @param {ArrayBuffer}  txdata
    送信するパケットデータ
  @param {number} rxsize
    受信するパケットのバイト数
  @param {function(boolean):void} callback
    コールバック関数
  @return {void}
   */

  AvsPackets.prototype.transPacket = function(channel, txdata, rxsize, callback) {
    var byte, dst, j, len, len1, src;
    channel &amp;= 0xff;
    src = new Uint8Array(txdata);
    dst = new Uint8Array(txdata.byteLength * 2 + 4);
    dst[0] = 0x7c;
    dst[1] = channel;
    dst[2] = 0x7a;
    len = 3;
    for (j = 0, len1 = src.length; j &lt; len1; j++) {
      byte = src[j];
      if ((0x7a &lt;= byte &amp;&amp; byte &lt;= 0x7d)) {
        dst[len] = 0x7d;
        len += 1;
        byte ^= 0x20;
      }
      dst[len] = byte;
      len += 1;
    }
    dst[len] = 0x7b;
    len += 1;
    txdata = dst.buffer.slice(0, len);
    this._base.transData(txdata, rxsize + 4, (function(_this) {
      return function(result, rxdata) {
        var pos, xor;
        if (!result) {
          return callback(false, null);
        }
        src = new Uint8Array(rxdata);
        dst = new Uint8Array(rxdata.byteLength - 4);
        if (!(src[0] === 0x7c &amp;&amp; src[1] === channel &amp;&amp; src[2] === 0x7a)) {
          return callback(false, null);
        }
        pos = 3;
        len = 0;
        xor = 0x00;
        while (pos &lt; src.byteLength) {
          byte = src[pos];
          pos += 1;
          switch (byte) {
            case 0x7a:
            case 0x7c:
              break;
            case 0x7b:
              return callback(true, dst.buffer.slice(0, len));
            case 0x7d:
              xor = 0x20;
              continue;
          }
          dst[len] = byte ^ xor;
          len += 1;
          xor = 0x00;
        }
        return callback(false, null);
      };
    })(this));
  };

  return AvsPackets;

})();


<span id='Canarium-AvmTransactions'>/**
</span>@class Canarium.AvmTransactions
PERIDOTボードAvalon-MMトランザクション層通信クラス
@uses Canarium.AvsPackets
 */

Canarium.AvmTransactions = (function() {
  var AVM_TRANS_MAX_BYTES, DEBUG;

  DEBUG = (DEBUG != null) || 0;


<span id='Canarium-AvmTransactions-property-_avs'>  /**
</span>  @private
  @property {Canarium.AvsPackets}
    Avalon-STパケット層通信クラスのインスタンス
   */

  AvmTransactions.prototype._avs = null;


<span id='Canarium-AvmTransactions-property-_channel'>  /**
</span>  @private
  @property {number}
    パケットのチャネル番号
   */

  AvmTransactions._channel = null;


<span id='Canarium-AvmTransactions-property-AVM_TRANS_MAX_BYTES'>  /**
</span>  @private
  @property {number}
    1回のトランザクションで読み書きできる最大バイト数
  @readonly
   */

  AVM_TRANS_MAX_BYTES = 32768;


<span id='Canarium-AvmTransactions-method-AvmTransactions'>  /**
</span>  @method
    コンストラクタ
  @param {Canarium.AvsPackets} _avs
    Avalon-STパケット層通信クラスのインスタンス
  @param {number} _channel
    パケットのチャネル番号
   */

  function AvmTransactions(_avs, _channel) {
    this._avs = _avs;
    this._channel = _channel;
  }


<span id='Canarium-AvmTransactions-method-read'>  /**
</span>  @method
    AvalonMMメモリリード(IORD_DIRECT)
  @param {number} address
    読み込み元アドレス(バイト単位)
  @param {number} bytenum
    読み込むバイト数
  @param {function(boolean,ArrayBuffer):void} callback
    コールバック関数
  @return {void}
   */

  AvmTransactions.prototype.read = function(address, bytenum, callback) {
    var byteOffset, dst, remainder;
    dst = new Uint8Array(bytenum);
    byteOffset = 0;
    remainder = bytenum;
    new Function.Sequence((function(_this) {
      return function(seq) {
        var len;
        len = Math.min(remainder, AVM_TRANS_MAX_BYTES);
        return _this._trans(0x14, address + byteOffset, null, len, function(result, partialData) {
          if (!result) {
            return seq.abort();
          }
          dst.set(new Uint8Array(partialData), byteOffset);
          byteOffset += len;
          remainder -= len;
          if (remainder &gt; 0) {
            return seq.redo();
          }
          return seq.next();
        });
      };
    })(this)).final((function(_this) {
      return function(seq) {
        if (seq.aborted) {
          return callback(false, null);
        }
        return callback(true, dst.buffer);
      };
    })(this)).start();
  };


<span id='Canarium-AvmTransactions-method-write'>  /**
</span>  @method
    AvalonMMメモリライト(IOWR_DIRECT)
  @param {number} address
    書き込み先アドレス(バイト単位)
  @param {ArrayBuffer} writedata
    書き込むデータ
  @param {function(boolean):void} callback
    コールバック関数
  @return {void}
   */

  AvmTransactions.prototype.write = function(address, writedata, callback) {
    var byteOffset, remainder, src;
    src = new Uint8Array(writedata);
    byteOffset = 0;
    remainder = writedata.byteLength;
    new Function.Sequence((function(_this) {
      return function(seq) {
        var len;
        len = Math.min(remainder, AVM_TRANS_MAX_BYTES);
        return _this._trans(0x04, address + byteOffset, src.subarray(byteOffset, len), null, function(result) {
          if (!result) {
            return seq.abort();
          }
          byteOffset += len;
          remainder -= len;
          if (remainder &gt; 0) {
            return seq.redo();
          }
          return seq.next();
        });
      };
    })(this)).final((function(_this) {
      return function(seq) {
        return callback(seq.finished);
      };
    })(this)).start();
  };


<span id='Canarium-AvmTransactions-method-iord'>  /**
</span>  @method
    AvalonMMペリフェラルリード(IORD)
  @param {number} address
    読み込み元ベースアドレス(バイト単位。ただし自動的に4バイトの倍数に切り捨てられる)
  @param {number} offset
    オフセット(4バイトワード単位)
  @param {function(boolean,number):void}  callback
    コールバック関数
  @return {void}
   */

  AvmTransactions.prototype.iord = function(address, offset, callback) {
    this._trans(0x10, (address &amp; 0xfffffffc) + (offset &lt;&lt; 2), null, 4, function(result, rxdata) {
      var readData, src;
      if (!result) {
        return callback(false, null);
      }
      src = new Uint8Array(rxdata);
      readData = (src[3] &lt;&lt; 24) | (src[2] &lt;&lt; 16) | (src[1] &lt;&lt; 8) | (src[0] &lt;&lt; 0);
      return callback(true, readData);
    });
  };


<span id='Canarium-AvmTransactions-method-iowr'>  /**
</span>  @method
    AvalonMMペリフェラルライト(IOWR)
  @param {number} address
    書き込み先ベースアドレス(バイト単位。ただし自動的に4バイトの倍数に切り捨てられる)
  @param {number} offset
    オフセット(4バイトワード単位)
  @param {number} writedata
    書き込むデータ
  @param {function(boolean):void} callback
    コールバック関数
  @return {void}
   */

  AvmTransactions.prototype.iowr = function(address, offset, writedata, callback) {
    var src;
    src = new Uint8Array(4);
    src[0] = (writedata &gt;&gt;&gt; 24) &amp; 0xff;
    src[1] = (writedata &gt;&gt;&gt; 16) &amp; 0xff;
    src[2] = (writedata &gt;&gt;&gt; 8) &amp; 0xff;
    src[3] = (writedata &gt;&gt;&gt; 0) &amp; 0xff;
    this._trans(0x00, (address &amp; 0xfffffffc) + (offset &lt;&lt; 2), src, 4, function(result) {
      return callback(result);
    });
  };


<span id='Canarium-AvmTransactions-method-option'>  /**
</span>  @method
    AvalonMMオプション設定 
  @param {Object} option
    オプション
  @param {boolean}  option.fastAcknowledge
    即時応答ビットを立てるかどうか
  @param {function(boolean):void} callback
    コールバック関数
  @return {void}
   */

  AvmTransactions.prototype.option = function(option, callback) {};


<span id='Canarium-AvmTransactions-method-_trans'>  /**
</span>  @private
  @method
    トランザクションの発行
  @param {number} transCode
    トランザクションコード
  @param {number} address
    アドレス
  @param {Uint8Array/null} txdata
    送信パケットに付加するデータ(受信時はnull)
  @param {null/number}  rxsize
    受信するバイト数(送信時はnull)
  @param {function(boolean,ArrayBuffer):void} callback
    コールバック関数
  @return {void}
   */

  AvmTransactions.prototype._trans = function(transCode, address, txdata, rxsize, callback) {
    var len, pkt;
    len = (txdata != null ? txdata.byteLength : void 0) || rxsize;
    pkt = new Uint8Array(8 + ((txdata != null ? txdata.byteLength : void 0) || 0));
    pkt[0] = transCode;
    pkt[1] = 0x00;
    pkt[2] = (len &gt;&gt;&gt; 8) &amp; 0xff;
    pkt[3] = (len &gt;&gt;&gt; 0) &amp; 0xff;
    pkt[4] = (address &gt;&gt;&gt; 24) &amp; 0xff;
    pkt[5] = (address &gt;&gt;&gt; 16) &amp; 0xff;
    pkt[6] = (address &gt;&gt;&gt; 8) &amp; 0xff;
    pkt[7] = (address &gt;&gt;&gt; 0) &amp; 0xff;
    if (txdata) {
      pkt.set(txdata, 8);
    }
    this._avs.transPacket(this._channel, pkt.buffer, (rxsize || 0) + 4, (function(_this) {
      return function(result, rxdata) {
        var src;
        if (!result) {
          return callback(false, null);
        }
        src = new Uint8Array(rxdata);
        if (!(src[0] === pkt[0] ^ 0x80 &amp;&amp; src[2] === pkt[2] &amp;&amp; src[3] === pkt[3])) {
          return callback(false, null);
        }
        return callback(true, rxdata.buffer(4));
      };
    })(this));
  };

  return AvmTransactions;

})();
</pre>
</body>
</html>
