/**********************************************************************************
 * PERIDOT Chrome Apps driver - 'Canarium' (Version 0.99.0)
 * Copyright (C) 2016 @kimu_shu and @s_osafune
 *********************************************************************************/
// Additional part of Canarium (since version 0.9.7) is distributed under the    //
// following license:                                                            //
//                                                                               //
// The MIT License (MIT)                                                         //
//                                                                               //
// Copyright (c) 2016 Shuta Kimura (@kimu_shu)                                   //
//                                                                               //
// Permission is hereby granted, free of charge, to any person obtaining a copy  //
// of this software and associated documentation files (the "Software"), to deal //
// in the Software without restriction, including without limitation the rights  //
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell     //
// copies of the Software, and to permit persons to whom the Software is         //
// furnished to do so, subject to the following conditions:                      //
//                                                                               //
// The above copyright notice and this permission notice shall be included in    //
// all copies or substantial portions of the Software.                           //
//                                                                               //
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR    //
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,      //
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE   //
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER        //
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, //
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN     //
// THE SOFTWARE.                                                                 //
// ----------------------------------------------------------------------------- //
// The original version of Canarium (below version 0.9.6) is written by          //
// @s_osafune and distributed under the following license:                       //
//                                                                               //
//     Copyright (C) 2014, J-7SYSTEM Works.  All rights Reserved.                //
//                                                                               //
// * This module is a free sourcecode and there is NO WARRANTY.                  //
// * No restriction on use. You can use, modify and redistribute it for          //
//   personal, non-profit or commercial products UNDER YOUR RESPONSIBILITY.      //
// * Redistributions of source code must retain the above copyright notice.      //
//                                                                               //
//         PERIDOT Project - https://github.com/osafune/peridot                  //
// ***************************************************************************** //
// Generated by CoffeeScript 1.12.4

/*
canarium.jsの先頭に配置されるスクリプト。
共通関数定義を行う。
 */

(function() {
  var Canarium, FIFOBuffer, IS_CHROME, IS_NODEJS, Promise, TimeLimit, dump, finallyPromise, getCurrentTime, hexDump, invokeCallback, oldProperty, ref, str2ab, tryPromise, waitPromise,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  if (false) {
    Uint8Array.prototype.hexDump = function() {
      return hexDump(this);
    };
  }


  /*
  @private
  @property {boolean}
    Chromeかどうかの判定
   */

  IS_CHROME = ((typeof chrome !== "undefined" && chrome !== null ? chrome.runtime : void 0) != null);


  /*
  @private
  @property {boolean}
    Node.jsかどうかの判定
   */

  IS_NODEJS = !IS_CHROME && (typeof process !== "undefined" && process !== null) && (typeof require !== "undefined" && require !== null);


  /*
  @private
  @property {Function}
    Promiseクラス
   */

  if (IS_CHROME) {
    Promise = window.Promise;
  } else if (IS_NODEJS) {
    Promise = (ref = global.Promise) != null ? ref : require("es6-promise").Promise;
  }

  oldProperty = Function.prototype.property;


  /*
  @private
  @method
    Object.definePropertyによるプロパティ定義メソッド
  @param {string} prop
    プロパティの名前
  @param {Object} desc
    プロパティのディスクリプタ
   */

  Function.prototype.property = function(prop, desc) {
    return Object.defineProperty(this.prototype, prop, desc);
  };


  /**
  @private
  @method
    16進ダンプ表示の文字列に変換
  @param {number/number[]/ArrayBuffer/Uint8Array} data
    変換するデータ
  @param {number} [maxBytes]
    最長バイト数(省略時無制限)
  @return {string}
    変換後の文字列
   */

  hexDump = function(data, maxBytes) {
    var brace, hex, i, len, r;
    brace = true;
    if (typeof data === "number") {
      brace = false;
      data = [data];
    } else if (data instanceof ArrayBuffer) {
      data = new Uint8Array(data);
    } else if (data instanceof Uint8Array) {
      null;
    } else if (data instanceof Array) {
      null;
    } else {
      throw Error("Unsupported data type: " + data);
    }
    len = data.length;
    if (maxBytes != null) {
      len = Math.min(len, maxBytes);
    }
    hex = function(v) {
      return "0x" + (v < 16 ? "0" : "") + ((v != null ? typeof v.toString === "function" ? v.toString(16) : void 0 : void 0) || "??");
    };
    r = ((function() {
      var j, ref1, results;
      results = [];
      for (i = j = 0, ref1 = len; 0 <= ref1 ? j < ref1 : j > ref1; i = 0 <= ref1 ? ++j : --j) {
        results.push(hex(data[i]));
      }
      return results;
    })()).join(",");
    if (data.length > len) {
      r += "...";
    }
    if (brace) {
      r = "[" + r + "]";
    }
    return r;
  };


  /**
  @private
  @method
    UTF-8文字列からArrayBufferに変換
  @param {string} str
    UTF-8文字列
  @return {ArrayBuffer}
    変換されたArrayBuffer
   */

  str2ab = function(str) {
    var ary, buf, c, i, j, len, pos, ref1;
    len = str.length;
    ary = new Uint8Array(len * 4);
    pos = 0;
    for (i = j = 0, ref1 = len; 0 <= ref1 ? j < ref1 : j > ref1; i = 0 <= ref1 ? ++j : --j) {
      c = str.charCodeAt(i);
      if (c < 0x80) {
        ary[pos++] = c;
      } else if (c < 0x800) {
        ary[pos++] = 0xc0 | (c >>> 6);
        ary[pos++] = 0x80 | (c & 0x3f);
      } else if (c < 0x10000) {
        ary[pos++] = 0xe0 | (c >>> 12);
        ary[pos++] = 0x80 | ((c >>> 6) & 0x3f);
        ary[pos++] = 0x80 | (c & 0x3f);
      } else {
        ary[pos++] = 0xf0 | (c >>> 18);
        ary[pos++] = 0x80 | ((c >>> 12) & 0x3f);
        ary[pos++] = 0x80 | ((c >>> 6) & 0x3f);
        ary[pos++] = 0x80 | (c & 0x3f);
      }
    }
    buf = new Uint8Array(pos);
    buf.set(ary.subarray(0, pos), 0);
    return buf.buffer;
  };


  /**
  @private
  @method
    Promiseオブジェクトからcallbackを呼び出し
  @param {function(boolean,Object)/undefined} callback
    呼び出し先コールバック関数。省略時は引数promiseをそのまま返すだけの動作となる。
    第1引数はPromiseオブジェクトの実行成否(true/false)を示す。
    第2引数はthen節/catch節の引数をそのまま渡す。
  @param {Promise} promise
    実行するPromiseオブジェクト
  @return {undefined/Promise}
    Promiseオブジェクト(callbackがundefinedの場合のみ)
   */

  invokeCallback = function(callback, promise) {
    if (!callback) {
      return promise;
    }
    promise.then(function(value) {
      callback(true, value);
    }, function(reason) {
      callback(false, reason);
    });
  };


  /**
  @private
  @method
    指定時間待機するPromiseオブジェクトを生成
  @param {number} dulation
    待機時間(ミリ秒単位)
  @param {Object} [value]
    成功時にPromiseValueとして渡されるオブジェクト
  @return {Promise}
    Promiseオブジェクト
   */

  waitPromise = function(dulation, value) {
    return new Promise(function(resolve) {
      return setTimeout((function() {
        return resolve(value);
      }), dulation);
    });
  };


  /**
  @private
  @method
    成功するまで繰り返すPromiseオブジェクトを生成
  @param {number} timeout
    最大待機時間(ミリ秒単位)
  @param {function():Promise} promiser
    繰り返す動作のPromiseを生成する関数
  @param {number} [maxTries]
    最大繰り返し回数(省略時：無制限)
  @return {Promise}
    生成されたPromiseオブジェクト
   */

  tryPromise = function(timeout, promiser, maxTries) {
    var count;
    count = 0;
    return new Promise(function(resolve, reject) {
      var lastReason, next;
      lastReason = void 0;
      next = function() {
        return promiser().then(function(value) {
          return resolve(value);
        }, function(reason) {
          lastReason = reason;
          count++;
          if ((maxTries != null) && count >= maxTries) {
            return reject(lastReason);
          }
          return setTimeout(function() {
            return typeof next === "function" ? next() : void 0;
          }, 0);
        });
      };
      setTimeout(function() {
        next = null;
        return reject(lastReason || Error("Operation timed out after " + count + " tries"));
      }, timeout);
      return next();
    });
  };


  /**
  @private
  @method
    Promiseの成功失敗にかかわらず実行する関数のペアを生成
  @return {Function[]}
    成功(fulfilled)と失敗(rejected)の関数ペア。
    promise.then(finallyPromise(-> 中身)...) として用いる。...を忘れないこと。
   */

  finallyPromise = function(action) {
    return [
      function(value) {
        action();
        return value;
      }, function(error) {
        action();
        return Promise.reject(error);
      }
    ];
  };


  /**
  @private
  @method
    パフォーマンス計測用の現在時刻取得(ミリ秒単位)
  @return {number}
    時刻情報
   */

  getCurrentTime = IS_CHROME ? (function() {
    return window.performance.now();
  }) : IS_NODEJS ? (function() {
    var t;
    t = process.hrtime();
    return Math.round(t[0] * 1000000 + t[1] / 1000) / 1000;
  }) : void 0;


  /**
  @private
  @class TimeLimit
    タイムアウト検出クラス
   */

  TimeLimit = (function() {

    /**
    @method constructor
      コンストラクタ
    @param {number} timeout
      タイムアウト時間(ms)
     */
    function TimeLimit(timeout1) {
      this.timeout = timeout1;
      this.start = this.now;
      return;
    }


    /**
    @property {number} now
      現在時刻(残り時間ではない)
    @readonly
     */

    TimeLimit.property("now", {
      get: getCurrentTime
    });


    /**
    @property {number} left
      残り時間(ms)
    @readonly
     */

    TimeLimit.property("left", {
      get: function() {
        return Math.max(0, this.timeout - parseInt(this.now - this.start));
      }
    });

    return TimeLimit;

  })();


  /**
  @private
  @class FIFOBuffer
    自動伸張FIFOバッファクラス
   */

  FIFOBuffer = (function() {

    /**
    @method constructor
      コンストラクタ
    @param {number} [capacity=128]
      初期バイト数
     */
    function FIFOBuffer(capacity) {
      if (capacity == null) {
        capacity = 128;
      }
      this.buffer = new ArrayBuffer(capacity);
      this.length = 0;
      return;
    }


    /**
    @method
      データを末尾に保存
    @param {Uint8Array/ArrayBuffer} data
      保存するデータ
    @return {undefined}
     */

    FIFOBuffer.prototype.push = function(data) {
      var capacity, newBuffer, newLength;
      if (data instanceof ArrayBuffer) {
        data = new Uint8Array(data);
      }
      newLength = this.length + data.length;
      capacity = this.buffer.byteLength;
      if (newLength > capacity) {
        if (capacity < 1) {
          capacity = 1;
        }
        while (newLength > capacity) {
          capacity *= 2;
        }
        newBuffer = new ArrayBuffer(capacity);
        new Uint8Array(newBuffer).set(new Uint8Array(this.buffer));
        this.buffer = newBuffer;
      }
      new Uint8Array(this.buffer).set(data, this.length);
      this.length = newLength;
    };


    /**
    @method
      データを先頭から取り出し
    @param {number} length
      取り出すバイト数
    @return {ArrayBuffer}
      取り出したデータ
     */

    FIFOBuffer.prototype.shift = function(length) {
      var array, result;
      if (length > this.length) {
        length = this.length;
      }
      result = new Uint8Array(length);
      if (length > 0) {
        array = new Uint8Array(this.buffer);
        result.set(array.subarray(0, length));
        array.set(array.subarray(length, this.length));
        this.length -= length;
      }
      return result.buffer;
    };

    return FIFOBuffer;

  })();


  /**
  @class Canarium
    PERIDOTボードドライバ
   */

  Canarium = (function() {
    null;

    /**
    @property {string} version
      ライブラリのバージョン
     */
    var AVM_CHANNEL, BOARDID_GENERIC, BOARDID_NEWGEN, BOARDID_STANDARD, BOARDID_VIRTUAL, CONFIG_TIMEOUT_MS, EEPROM_SLAVE_ADDR, RECONFIG_TIMEOUT_MS, SPLIT_EEPROM_BURST;

    Canarium.property("version", {
      value: "0.99.0"
    });


    /**
    @property {Object}  boardInfo
      接続しているボードの情報
    
    @property {string}  boardInfo.id
      ボードの識別子(以下のうちいずれか)
    
      - 'J72A' (PERIDOT Standard)
      - 'J72N' (PERIDOT NewGen)
      - 'J72B' (Virtual - コンフィグレーションレイヤをFPGA側に内蔵)
      - 'J72X' (Generic - Avalon-MMブリッジのみ使う汎用型)
    
    @property {string}  boardInfo.serialcode
      'xxxxxx-yyyyyy-zzzzzz'
     */

    Canarium.property("boardInfo", {
      get: function() {
        return this._boardInfo;
      }
    });


    /**
    @property {number} serialBitrate
      デフォルトのビットレート({@link Canarium.BaseComm#bitrate}のアクセサとして定義)
     */

    Canarium.property("serialBitrate", {
      get: function() {
        return this._base.bitrate;
      },
      set: function(v) {
        return this._base.bitrate = v;
      }
    });


    /**
    @property {boolean} connected
      接続状態({@link Canarium.BaseComm#connected}のアクセサとして定義)
    
      - true: 接続済み
      - false: 未接続
    @readonly
     */

    Canarium.property("connected", {
      get: function() {
        return this._base.connected;
      }
    });


    /**
    @property {boolean} configured
      コンフィグレーション状態({@link Canarium.BaseComm#configured}のアクセサとして定義)
    
      - true: コンフィグレーション済み
      - false: 未コンフィグレーション
    @readonly
     */

    Canarium.property("configured", {
      get: function() {
        return this._base.configured;
      }
    });


    /**
    @property {Canarium.I2CComm} i2c
      I2C通信制御クラスのインスタンス
    @readonly
     */

    Canarium.property("i2c", {
      get: function() {
        return this._i2c;
      }
    });


    /**
    @property {Canarium.AvsPackets} avs
      Avalon-STパケット層通信クラスのインスタンス
    @readonly
     */

    Canarium.property("avs", {
      get: function() {
        return this._avs;
      }
    });


    /**
    @property {Canarium.AvmTransactions} avm
      Avalon-MMトランザクション層通信クラスのインスタンス
    @readonly
     */

    Canarium.property("avm", {
      get: function() {
        return this._avm;
      }
    });


    /**
    @property {Canarium.RpcClient} rpcClient
      RPCクライアントクラスのインスタンス
    @readonly
     */

    Canarium.property("rpcClient", {
      get: function() {
        return this._rpcClient;
      }
    });


    /**
    @property {number} swiBase
      ホスト通信用ペリフェラル(SWI)のベースアドレス
      ({@link Canarium.AvmTransactions#swiBase}のアクセサとして定義)
     */

    Canarium.property("swiBase", {
      get: function() {
        return this._avm.swiBase;
      },
      set: function(v) {
        return this._avm.swiBase = v;
      }
    });


    /**
    @property {function()} onClosed
    @inheritdoc Canarium.BaseComm#onClosed
     */

    Canarium.property("onClosed", {
      get: function() {
        return this._base.onClosed;
      },
      set: function(v) {
        return this._base.onClosed = v;
      }
    });


    /**
    @static
    @property {number}
      デバッグ出力の細かさ(0で出力無し)
     */

    Canarium.verbosity = 0;


    /**
    @private
    @property {Canarium.BaseComm} _base
      下位層通信クラスのインスタンス
     */


    /**
    @private
    @property {boolean} _configBarrier
      コンフィグレーション中を示すフラグ(再帰実行禁止用)
     */


    /**
    @private
    @property {boolean} _resetBarrier
      リセット中を示すフラグ(再帰実行禁止用)
     */


    /**
    @private
    @static
    @cfg {number} EEPROM_SLAVE_ADDR = 0b1010000
      EEPROMのスレーブアドレス(7-bit表記)
    @readonly
     */

    EEPROM_SLAVE_ADDR = 0x50;


    /**
    @private
    @static
    @cfg {number} SPLIT_EEPROM_BURST = 6
      EEPROMの最大バーストリード長(バイト数)
    @readonly
     */

    SPLIT_EEPROM_BURST = 6;


    /**
    @private
    @static
    @cfg {number} CONFIG_TIMEOUT_MS = 3000
      コンフィグレーション開始のタイムアウト時間(ms)
    @readonly
     */

    CONFIG_TIMEOUT_MS = 3000;


    /**
    @private
    @static
    @cfg {number} RECONFIG_TIMEOUT_MS = 3000
      リコンフィグレーションのタイムアウト時間(ms)
    @readonly
     */

    RECONFIG_TIMEOUT_MS = 3000;


    /**
    @private
    @static
    @cfg {number} AVM_CHANNEL = 0
      Avalon-MM 通信レイヤのチャネル番号
    @readonly
     */

    AVM_CHANNEL = 0;


    /**
    @private
    @static
    @cfg {string} BOARDID_STANDARD = "J72A"
      標準PERIDOTのボードID
    @readonly
     */

    BOARDID_STANDARD = "J72A";


    /**
    @private
    @static
    @cfg {string} BOARDID_NEWGEN = "J72N"
      PERIDOT-NewGenのボードID
    @readonly
     */

    BOARDID_NEWGEN = "J72N";


    /**
    @private
    @static
    @cfg {string} BOARDID_VIRTUAL = "J72B"
      VirtualモードHostbridgeのボードID
    @readonly
     */

    BOARDID_VIRTUAL = "J72B";


    /**
    @private
    @static
    @cfg {string} BOARDID_GENERIC = "J72X"
      GenericモードHostbridgeのボードID
    @readonly
     */

    BOARDID_GENERIC = "J72X";


    /**
    @static
    @method
      接続対象デバイスを列挙する
      (PERIDOTでないデバイスも列挙される可能性があることに注意)
    @param {function(boolean,Object[]/Error)} [callback]
      コールバック関数(省略時は戻り値としてPromiseオブジェクトを返す)
    @return {undefined/Promise}
      戻り値なし(callback指定時)、または、Promiseオブジェクト
    @return {Object[]} return.PromiseValue
      デバイスの配列(各要素は次のメンバを持つ)
    
      - name : UI向け名称(COMxxなど)
      - path : 内部管理向けパス
     */

    Canarium.enumerate = function(callback) {
      if (callback != null) {
        return invokeCallback(callback, this.enumerate());
      }
      return Canarium.BaseComm.enumerate();
    };


    /**
    @method constructor
      コンストラクタ
     */

    function Canarium() {
      this._boardInfo = null;
      this._base = new Canarium.BaseComm();
      this._i2c = new Canarium.I2CComm(this._base);
      this._avs = new Canarium.AvsPackets(this._base);
      this._avm = new Canarium.AvmTransactions(this._avs, AVM_CHANNEL);
      this._rpcClient = new Canarium.RpcClient(this._avm);
      this._configBarrier = false;
      this._resetBarrier = false;
      return;
    }


    /**
    @method
      ボードに接続する
    @param {string} path
      接続先パス(enumerateが返すpath)
    @param {Object} [boardInfo]
      接続先ボードのIDやrbfデータなど(省略時はIDチェックやコンフィグレーションをしない)
    @param {string} [boardInfo.id]
      接続を許容するID(省略時はIDのチェックをしない)
    @param {string} [boardInfo.serialcode]
      接続を許容するシリアル番号(省略時はシリアル番号のチェックをしない)
    @param {ArrayBuffer} [boardInfo.rbfdata]
      接続後に書き込むrbfやrpdのデータ(省略時は接続後にコンフィグレーションをしない)
    @param {function(boolean,Error=)} [callback]
      コールバック関数(省略時は戻り値としてPromiseオブジェクトを返す)
    @return {undefined/Promise}
      戻り値なし(callback指定時)、または、Promiseオブジェクト(callback省略時)
     */

    Canarium.prototype.open = function(path, boardInfo, callback) {
      if (typeof boardInfo === "function") {
        callback = boardInfo;
        boardInfo = null;
      }
      if (callback != null) {
        return invokeCallback(callback, this.open(path, boardInfo));
      }
      return Promise.resolve().then((function(_this) {
        return function() {
          return _this._base.connect(path);
        };
      })(this)).then((function(_this) {
        return function() {
          return Promise.resolve().then(function() {
            _this._boardInfo = null;
            return _this._eepromRead(0x00, 4);
          }).then(function(readData) {
            var header;
            header = new Uint8Array(readData);
            if (!(header[0] === 0x4a && header[1] === 0x37 && header[2] === 0x57)) {
              return Promise.reject(Error("EEPROM header is invalid"));
            }
            _this._log(1, "open", "done(version=" + (hexDump(header[3])) + ")");
            _this._boardInfo = {
              version: header[3]
            };
            return _this._base.transCommand(0x39);
          }).then(function(response) {
            return _this._base.option({
              forceConfigured: (response & 0x04) !== 0
            });
          }).then(function() {
            return _this._validate(boardInfo);
          }).then(function() {
            if ((boardInfo != null ? boardInfo.rbfdata : void 0) == null) {
              return;
            }
            return _this.config(null, boardInfo.rbfdata);
          }).then(function() {})["catch"](function(error) {
            return _this._base.disconnect()["catch"](function() {}).then(function() {
              return Promise.reject(error);
            });
          });
        };
      })(this));
    };


    /**
    @method
      PERIDOTデバイスポートのクローズ
    @param {function(boolean,Error=)} [callback]
      コールバック関数(省略時は戻り値としてPromiseオブジェクトを返す)
    @return {undefined/Promise}
      戻り値なし(callback指定時)、または、Promiseオブジェクト(callback省略時)
     */

    Canarium.prototype.close = function(callback) {
      if (callback != null) {
        return invokeCallback(callback, this.close());
      }
      return Promise.resolve().then((function(_this) {
        return function() {
          return _this._base.disconnect();
        };
      })(this)).then((function(_this) {
        return function() {
          _this._boardInfo = null;
        };
      })(this));
    };


    /**
    @method
      ボードのFPGAコンフィグレーション
    @param {Object/null} boardInfo
      ボード情報(ボードIDやシリアル番号を限定したい場合)
    @param {string} [boardInfo.id]
      ボードID (省略時は"J72A")
    @param {string} [boardInfo.serialcode]
      シリアル番号
    @param {ArrayBuffer} rbfdata
      rbfまたはrpdのデータ
    @param {function(boolean,Error=)} [callback]
      コールバック関数(省略時は戻り値としてPromiseオブジェクトを返す)
    @return {undefined/Promise}
      戻り値なし(callback指定時)、または、Promiseオブジェクト(callback省略時)
     */

    Canarium.prototype.config = function(boardInfo, rbfdata, callback) {
      var ref1, timeLimit;
      if (callback != null) {
        return invokeCallback(callback, this.config(boardInfo, rbfdata));
      }
      if (this._configBarrier) {
        return Promise.reject(Error("Configuration is now in progress"));
      }
      this._configBarrier = true;
      timeLimit = void 0;
      return (ref1 = Promise.resolve().then((function(_this) {
        return function() {
          var info, ref2;
          info = {
            id: (ref2 = boardInfo != null ? boardInfo.id : void 0) != null ? ref2 : BOARDID_STANDARD,
            serialcode: boardInfo != null ? boardInfo.serialcode : void 0
          };
          return _this._validate(info);
        };
      })(this)).then((function(_this) {
        return function() {
          return _this._base.transCommand(0x3b);
        };
      })(this)).then((function(_this) {
        return function(response) {
          if ((response & 0x01) !== 0x00) {
            return Promise.reject(Error("Not PS mode"));
          }
        };
      })(this)).then((function(_this) {
        return function() {
          return timeLimit = new TimeLimit(CONFIG_TIMEOUT_MS);
        };
      })(this)).then((function(_this) {
        return function() {
          return tryPromise(timeLimit.left, function() {
            return _this._base.transCommand(0x32).then(function(response) {
              if ((response & 0x06) !== 0x00) {
                return Promise.reject();
              }
            });
          });
        };
      })(this)).then((function(_this) {
        return function() {
          return tryPromise(timeLimit.left, function() {
            return _this._base.transCommand(0x33).then(function(response) {
              if ((response & 0x06) !== 0x02) {
                return Promise.reject();
              }
            });
          });
        };
      })(this)).then((function(_this) {
        return function() {
          return _this._base.transData(rbfdata);
        };
      })(this)).then((function(_this) {
        return function() {
          return _this._base.transCommand(0x33);
        };
      })(this)).then((function(_this) {
        return function(response) {
          if ((response & 0x06) !== 0x06) {
            return Promise.reject(Error("FPGA configuration failed"));
          }
        };
      })(this)).then((function(_this) {
        return function() {
          return _this._base.transCommand(0x39);
        };
      })(this)).then((function(_this) {
        return function(response) {
          return _this._base.option({
            forceConfigured: (response & 0x04) !== 0
          });
        };
      })(this)).then((function(_this) {
        return function() {};
      })(this))).then.apply(ref1, finallyPromise((function(_this) {
        return function() {
          return _this._configBarrier = false;
        };
      })(this)));
    };


    /**
    @method
      ボードのFPGA再コンフィグレーション
    @since 0.9.20
     */

    Canarium.prototype.reconfig = function(callback) {
      var ref1, timeLimit;
      if (callback != null) {
        return invokeCallback(callback, this.reconfig());
      }
      if (this._configBarrier) {
        return Promise.reject(Error("(Re)configuration is now in progress"));
      }
      this._configBarrier = true;
      timeLimit = void 0;
      return (ref1 = Promise.resolve().then((function(_this) {
        return function() {
          var ref2;
          if (((ref2 = _this._boardInfo) != null ? ref2.id : void 0) != null) {
            return;
          }
          return _this.getinfo();
        };
      })(this)).then((function(_this) {
        return function() {
          var ref2;
          if (((ref2 = _this._boardInfo) != null ? ref2.id : void 0) === BOARDID_STANDARD) {
            return Promise.reject(Error("reconfig() cannot be used on this board"));
          }
        };
      })(this)).then((function(_this) {
        return function() {
          return timeLimit = new TimeLimit(RECONFIG_TIMEOUT_MS);
        };
      })(this)).then((function(_this) {
        return function() {
          return tryPromise(timeLimit.left, function() {
            return _this._base.transCommand(0x32).then(function(response) {
              if ((response & 0x06) !== 0x00) {
                return Promise.reject();
              }
            });
          });
        };
      })(this)).then((function(_this) {
        return function() {
          return tryPromise(timeLimit.left, function() {
            return _this._base.transCommand(0x33).then(function(response) {
              if ((response & 0x06) !== 0x02) {
                return Promise.reject();
              }
            });
          });
        };
      })(this)).then((function(_this) {
        return function() {};
      })(this))).then.apply(ref1, finallyPromise((function(_this) {
        return function() {
          return _this._configBarrier = false;
        };
      })(this)));
    };


    /**
    @method
      ボードのマニュアルリセット
    @param {function(boolean,number/Error=)} [callback]
      コールバック関数(省略時は戻り値としてPromiseオブジェクトを返す)
    @return {undefined/Promise}
      戻り値なし(callback指定時)、または、Promiseオブジェクト(callback省略時)
    @return {number} return.PromiseValue
      レスポンスコマンド
     */

    Canarium.prototype.reset = function(callback) {
      var ref1;
      if (callback != null) {
        return invokeCallback(callback, this.reset());
      }
      if (this._resetBarrier) {
        return Promise.reject(Error("Reset is now in progress"));
      }
      this._resetBarrier = true;
      return (ref1 = Promise.resolve().then((function(_this) {
        return function() {
          return _this._base.transCommand(0x31);
        };
      })(this)).then((function(_this) {
        return function() {
          return waitPromise(100);
        };
      })(this)).then((function(_this) {
        return function() {
          return _this._base.transCommand(0x39);
        };
      })(this)).then((function(_this) {
        return function(response) {
          return response;
        };
      })(this))).then.apply(ref1, finallyPromise((function(_this) {
        return function() {
          return _this._resetBarrier = false;
        };
      })(this)));
    };


    /**
    @method
      ボード情報の取得
    @param {function(boolean,Object/Error=)} [callback]
      コールバック関数(省略時は戻り値としてPromiseオブジェクトを返す)
    @return {undefined/Promise}
      戻り値なし(callback指定時)、または、Promiseオブジェクト(callback省略時)
    @return {Object} return.PromiseValue
      ボード情報
    @return {string} return.PromiseValue.id
      ボードID
    @return {string} return.PromiseValue.serialcode
      シリアル番号
     */

    Canarium.prototype.getinfo = function(callback) {
      if (callback != null) {
        return invokeCallback(callback, this.getinfo());
      }
      return Promise.resolve().then((function(_this) {
        return function() {
          return _this._base.assertConnection();
        };
      })(this)).then((function(_this) {
        return function() {
          var ref1;
          switch ((ref1 = _this._boardInfo) != null ? ref1.version : void 0) {
            case void 0:
              return Promise.reject(Error("Boardinfo not loaded"));
            case 1:
              return _this._eepromRead(0x04, 8).then(function(readData) {
                var info, mid, pid, s, sid;
                info = new Uint8Array(readData);
                _this._log(1, "getinfo", "ver1", info);
                mid = (info[0] << 8) | (info[1] << 0);
                pid = (info[2] << 8) | (info[3] << 0);
                sid = (info[4] << 24) | (info[5] << 16) | (info[6] << 8) | (info[7] << 0);
                if (mid === 0x0072) {
                  s = "" + (pid.hex(4)) + (sid.hex(8));
                  _this._boardInfo.id = BOARDID_STANDARD;
                  return _this._boardInfo.serialcode = (s.substr(0, 6)) + "-" + (s.substr(6, 6)) + "-000000";
                }
              });
            case 2:
              return _this._eepromRead(0x04, 22).then(function(readData) {
                var bid, i, info, j, l, s;
                info = new Uint8Array(readData);
                _this._log(1, "getinfo", "ver2", info);
                bid = "";
                for (i = j = 0; j < 4; i = ++j) {
                  bid += String.fromCharCode(info[i]);
                }
                s = "";
                for (i = l = 4; l < 22; i = ++l) {
                  s += String.fromCharCode(info[i]);
                }
                _this._boardInfo.id = "" + bid;
                return _this._boardInfo.serialcode = (s.substr(0, 6)) + "-" + (s.substr(6, 6)) + "-" + (s.substr(12, 6));
              });
            default:
              return Promise.reject(Error("Unknown boardinfo version"));
          }
        };
      })(this)).then((function(_this) {
        return function() {
          return _this.boardInfo;
        };
      })(this));
    };


    /**
    @method
      ボード上のファイルを開く
    @param {string} path
      パス
    @param {number/Object} flags
      フラグ(数字指定またはECMAオブジェクト指定)
    @param {boolean} flags.O_WRONLY
      書き込み専用
    @param {boolean} flags.O_RDONLY
      読み込み専用
    @param {boolean} flags.O_RDWR
      読み書き両用
    @param {boolean} flags.O_APPEND
      追記モード
    @param {boolean} flags.O_CREAT
      作成モード
    @param {boolean} flags.O_NONBLOCK
      非ブロッキングモード
    @param {boolean} flags.O_TRUNC
      切り詰め(truncate)モード
    @param {number} [mode]
      ファイル作成時のパーミッション
    @param {number} [interval]
      RPCポーリング周期
    @param {function(boolean,Canarium.RemoteFile/Error=)} [callback]
      コールバック関数(省略時は戻り値としてPromiseオブジェクトを返す)
    @return {undefined/Promise}
      戻り値なし(callback指定時)、または、Promiseオブジェクト(callback省略時)
    @return {Canarium.RemoteFile} return.PromiseValue
      開かれたファイルに対する操作クラスのインスタンス
     */

    Canarium.prototype.openRemoteFile = function(path, flags, mode, interval, callback) {
      var ref1, ref2;
      if (typeof mode === "function") {
        ref1 = [null, null, mode], mode = ref1[0], interval = ref1[1], callback = ref1[2];
      } else if (typeof interval === "function") {
        ref2 = [null, interval], interval = ref2[0], callback = ref2[1];
      }
      if (callback != null) {
        return invokeCallback(callback, this.openRemoteFile(path, flags, mode, interval));
      }
      return Canarium.RemoteFile.open(this._rpcClient, path, flags, mode, interval);
    };


    /**
    @private
    @method
      EEPROMの読み出し
    @param {number} startaddr
      読み出し開始アドレス
    @param {number} readbytes
      読み出しバイト数
    @return {Promise}
      Promiseオブジェクト
    @return {ArrayBuffer} return.PromiseValue
      読み出し結果
     */

    Canarium.prototype._eepromRead = function(startaddr, readbytes) {
      var array, lastError, x;
      array = new Uint8Array(readbytes);
      if ((SPLIT_EEPROM_BURST != null) && readbytes > SPLIT_EEPROM_BURST) {
        return ((function() {
          var j, ref1, ref2, results;
          results = [];
          for (x = j = 0, ref1 = readbytes, ref2 = SPLIT_EEPROM_BURST; ref2 > 0 ? j < ref1 : j > ref1; x = j += ref2) {
            results.push(x);
          }
          return results;
        })()).reduce((function(_this) {
          return function(sequence, offset) {
            return sequence.then(function() {
              return _this._eepromRead(startaddr + offset, Math.min(SPLIT_EEPROM_BURST, readbytes - offset));
            }).then(function(partialData) {
              array.set(new Uint8Array(partialData), offset);
            });
          };
        })(this), Promise.resolve()).then((function(_this) {
          return function() {
            return array.buffer;
          };
        })(this));
      }
      lastError = null;
      return Promise.resolve().then((function(_this) {
        return function() {
          _this._log(1, "_eepromRead", "begin(addr=" + (hexDump(startaddr)) + ",bytes=" + (hexDump(readbytes)) + ")");
          return _this.i2c.start();
        };
      })(this)).then((function(_this) {
        return function() {
          return _this.i2c.write(EEPROM_SLAVE_ADDR << 1).then(function(ack) {
            if (!ack) {
              return Promise.reject(Error("EEPROM is not found."));
            }
          });
        };
      })(this)).then((function(_this) {
        return function() {
          return _this.i2c.write(startaddr & 0xff).then(function(ack) {
            if (!ack) {
              return Promise.reject(Error("Cannot write address in EEPROM"));
            }
          });
        };
      })(this)).then((function(_this) {
        return function() {
          return _this.i2c.start();
        };
      })(this)).then((function(_this) {
        return function() {
          return _this.i2c.write((EEPROM_SLAVE_ADDR << 1) + 1).then(function(ack) {
            if (!ack) {
              return Promise.reject(Error("EEPROM is not found."));
            }
          });
        };
      })(this)).then((function(_this) {
        return function() {
          var j, lastIndex, results;
          lastIndex = readbytes - 1;
          return (function() {
            results = [];
            for (var j = 0; 0 <= lastIndex ? j <= lastIndex : j >= lastIndex; 0 <= lastIndex ? j++ : j--){ results.push(j); }
            return results;
          }).apply(this).reduce(function(promise, index) {
            return promise.then(function() {
              return _this.i2c.read(index !== lastIndex);
            }).then(function(byte) {
              return array[index] = byte;
            });
          }, Promise.resolve());
        };
      })(this))["catch"]((function(_this) {
        return function(error) {
          lastError = error;
        };
      })(this)).then((function(_this) {
        return function() {
          return _this.i2c.stop();
        };
      })(this)).then((function(_this) {
        return function() {
          if (lastError) {
            return Promise.reject(lastError);
          }
          _this._log(1, "_eepromRead", "end", array);
          return array.buffer;
        };
      })(this));
    };


    /**
    @private
    @method
      接続先ボードのID/シリアル番号検証
    @param {Object} boardInfo
      検証するボード情報
    @param {string} [boardInfo.id]
      許可するボードID(省略時は検証しない)
    @param {string} [boardInfo.serialcode]
      許可するシリアル番号(省略時は検証しない)
    @return {Promise}
      Promiseオブジェクト(不一致が発生した場合、rejectされる)
    @return {undefined} return.PromiseValue
     */

    Canarium.prototype._validate = function(boardInfo) {
      return Promise.resolve().then((function(_this) {
        return function() {
          return _this._base.assertConnection();
        };
      })(this)).then((function(_this) {
        return function() {
          var ref1, ref2;
          if (!boardInfo || (((ref1 = _this.boardInfo) != null ? ref1.id : void 0) && ((ref2 = _this.boardInfo) != null ? ref2.serialcode : void 0))) {
            return;
          }
          return _this.getinfo();
        };
      })(this)).then((function(_this) {
        return function() {
          var mismatch;
          mismatch = function(a, b) {
            return (a != null) && a !== b;
          };
          if (mismatch(boardInfo != null ? boardInfo.id : void 0, _this.boardInfo.id)) {
            return Promise.reject(Error("Board ID mismatch"));
          }
          if (mismatch(boardInfo != null ? boardInfo.serialcode : void 0, _this.boardInfo.serialcode)) {
            return Promise.reject(Error("Board serial code mismatch"));
          }
        };
      })(this));
    };


    /**
    @private
    @static
    @method
      ログの出力(全クラス共通)
    @param {string} cls
      クラス名
    @param {string} func
      関数名
    @param {string} msg
      メッセージ
    @param {Object} [data]
      任意のデータ
    @return {undefined}
     */

    Canarium._log = function(cls, func, msg, data) {
      var obj1, out, time;
      if ((typeof SUPPRESS_ALL_LOGS !== "undefined" && SUPPRESS_ALL_LOGS !== null) && SUPPRESS_ALL_LOGS) {
        return;
      }
      time = getCurrentTime().toFixed(3);
      out = (
        obj1 = {
          time: time
        },
        obj1[cls + "#" + func] = msg,
        obj1.stack = new Error().stack.split(/\n\s*/).slice(1),
        obj1
      );
      if (data) {
        out.data = data;
      }
      if (this._logger != null) {
        this._logger(out);
      } else {
        console.log(out);
      }
    };


    /**
    @private
    @method
      ログの出力
    @param {number} lvl
      詳細度(0で常に出力。値が大きいほど詳細なメッセージを指す)
    @param {string} func
      関数名
    @param {string} msg
      メッセージ
    @param {Object} [data]
      任意のデータ
    @return {undefined}
     */

    Canarium.prototype._log = function(lvl, func, msg, data) {
      if (this.constructor.verbosity >= lvl) {
        Canarium._log("Canarium", func, msg, data);
      }
    };

    return Canarium;

  })();


  /**
  @class Canarium.BaseComm
    PERIDOTボード下位層通信クラス
  @uses Canarium.BaseComm.SerialWrapper
   */

  Canarium.BaseComm = (function() {
    null;

    /**
    @property {boolean} connected
      接続状態
    
      - true: 接続済み
      - false: 未接続
    @readonly
     */
    var SERIAL_TX_MAX_LENGTH, SUCCESSIVE_TX_WAIT_MS;

    BaseComm.property("connected", {
      get: function() {
        return this._connection != null;
      }
    });


    /**
    @property {string} path
      接続しているシリアル通信デバイスのパス
    @readonly
     */

    BaseComm.property("path", {
      get: function() {
        return "" + this._path;
      }
    });


    /**
    @property {number} bitrate
      ビットレート(bps)
     */

    BaseComm.property("bitrate", {
      get: function() {
        return this._bitrate;
      },
      set: function(v) {
        return this._bitrate = parseInt(v);
      }
    });


    /**
    @property {boolean} sendImmediate
      即時応答ビットを立てるかどうか
    @readonly
     */

    BaseComm.property("sendImmediate", {
      get: function() {
        return this._sendImmediate;
      }
    });


    /**
    @property {boolean} configured
      コンフィグレーション済みかどうか
    @readonly
     */

    BaseComm.property("configured", {
      get: function() {
        return this._configured;
      }
    });


    /**
    @property {function()} onClosed
      クローズされた時に呼び出されるコールバック関数
      (明示的にclose()した場合と、ボードが強制切断された場合の両方で呼び出される)
     */

    BaseComm.property("onClosed", {
      get: function() {
        return this._onClosed;
      },
      set: function(v) {
        return this._onClosed = v;
      }
    });


    /**
    @static
    @property {number}
      デバッグ出力の細かさ(0で出力無し)
     */

    BaseComm.verbosity = 0;


    /**
    @private
    @property {Canarium.BaseComm.SerialWrapper} _connection
      シリアル接続クラスのインスタンス
     */


    /**
    @private
    @property {number} _bitrate
    @inheritdoc #bitrate
     */


    /**
    @private
    @property {boolean} _sendImmediate
    @inheritdoc #sendImmediate
     */


    /**
    @private
    @property {boolean} _configured
    @inheritdoc #configured
     */


    /**
    @private
    @property {ArrayBuffer} _rxBuffer
      受信中データ
     */


    /**
    @private
    @property {function(ArrayBuffer=,Error=)} _receiver
      受信処理を行う関数
     */


    /**
    @private
    @static
    @cfg {number}
      1回のシリアル送信の最大バイト数
    @readonly
     */

    SERIAL_TX_MAX_LENGTH = 1024;


    /**
    @private
    @static
    @cfg {number}
      連続シリアル送信の間隔(ミリ秒)
    @readonly
     */

    SUCCESSIVE_TX_WAIT_MS = null;


    /**
    @static
    @method
      接続対象デバイスを列挙する
      (PERIDOTでないデバイスも列挙される可能性があることに注意)
    @return {Promise}
      Promiseオブジェクト
    @return {Object[]} return.PromiseValue
      デバイスの配列(各要素は次のメンバを持つ)
    
      - name : UI向け名称(COMxxなど)
      - path : 内部管理向けパス
     */

    BaseComm.enumerate = function() {
      var getFriendlyName;
      getFriendlyName = function(port) {
        var name, path;
        name = port.manufacturer;
        path = port.path;
        if (name && name !== "") {
          return name + " (" + path + ")";
        }
        return "" + path;
      };
      return BaseComm.SerialWrapper.list().then(function(ports) {
        var devices, j, len1, port;
        devices = [];
        for (j = 0, len1 = ports.length; j < len1; j++) {
          port = ports[j];
          devices.push({
            path: "" + port.path,
            name: getFriendlyName(port),
            vendorId: port.vendorId,
            productId: port.productId
          });
        }
        return devices;
      });
    };


    /**
    @method constructor
      コンストラクタ
     */

    function BaseComm() {
      this._connection = null;
      this._bitrate = 115200;
      this._sendImmediate = false;
      this._configured = false;
      return;
    }


    /**
    @method
      ボードに接続する
    @param {string} path
      接続先パス(enumerateが返すpath)
    @return {Promise}
      Promiseオブジェクト
     */

    BaseComm.prototype.connect = function(path) {
      if (this._connection != null) {
        return Promise.reject(Error("Already connected"));
      }
      this._connection = new BaseComm.SerialWrapper(path, {
        baudRate: this._bitrate
      });
      this._receiver = null;
      return this._connection.open().then((function(_this) {
        return function() {
          _this._connection.onClosed = function() {
            var base;
            _this._connection = null;
            if (typeof (base = _this._onClosed) === "function") {
              base();
            }
          };
          _this._connection.onReceived = function(data) {
            if (typeof _this._receiver === "function") {
              _this._receiver(data);
            }
          };
        };
      })(this))["catch"]((function(_this) {
        return function(error) {
          _this._connection = null;
          _this._receiver = null;
          return Promise.reject(error);
        };
      })(this));
    };


    /**
    @method
      オプション設定
    @param {Object} option
      オプション
    @param {boolean} option.sendImmediate
      即時応答ビットを有効にするかどうか
    @param {boolean} option.forceConfigured
      コンフィグレーション済みとして扱うかどうか
    @return {Promise}
      Promiseオブジェクト
     */

    BaseComm.prototype.option = function(option) {
      if (this._connection == null) {
        return Promise.reject(Error("Not connected"));
      }
      return Promise.resolve().then((function(_this) {
        return function() {
          var value;
          if ((value = option.fastAcknowledge) == null) {
            return;
          }
          _this._sendImmediate = !!value;
          return _this.transCommand(0x39 | (value ? 0x02 : 0x00));
        };
      })(this)).then((function(_this) {
        return function() {
          var value;
          if ((value = option.forceConfigured) == null) {
            return;
          }
          _this._configured = !!value;
        };
      })(this)).then((function(_this) {
        return function() {};
      })(this));
    };


    /**
    @method
      ボードから切断する
    @return {Promise}
      Promiseオブジェクト
     */

    BaseComm.prototype.disconnect = function() {
      return this.assertConnection().then((function(_this) {
        return function() {
          _this._receiver = null;
          return _this._connection.close()["catch"](function() {});
        };
      })(this));
    };


    /**
    @method
      接続されていることを確認する
    @return {Promise}
      Promiseオブジェクト
     */

    BaseComm.prototype.assertConnection = function() {
      if (this._connection == null) {
        return Promise.reject(Error("Not connected"));
      }
      return Promise.resolve();
    };


    /**
    @method
      制御コマンドの送受信を行う
    @param {number} command
      コマンドバイト
    @return {Promise}
      Promiseオブジェクト
    @return {number} return.PromiseValue
      受信コマンド
     */

    BaseComm.prototype.transCommand = function(command) {
      var txarray;
      txarray = new Uint8Array(2);
      txarray[0] = 0x3a;
      txarray[1] = command;
      return this._transSerial(txarray.buffer, (function(_this) {
        return function(rxdata) {
          if (!(rxdata.byteLength >= 1)) {
            return;
          }
          return 1;
        };
      })(this)).then((function(_this) {
        return function(rxdata) {
          return (new Uint8Array(rxdata))[0];
        };
      })(this));
    };


    /**
    @method
      データの送受信を行う
    @param {ArrayBuffer/null} txdata
      送信するデータ(制御バイトは自動的にエスケープされる。nullの場合は受信のみ)
    @param {function(ArrayBuffer,number):number/undefined/Error} [estimator]
      受信完了まで繰り返し呼び出される受信処理関数。
      引数は受信データ全体と、今回の呼び出しで追加されたデータのオフセット。
      省略時は送信のみで完了とする。戻り値の解釈は以下の通り。
    
      - number : 指定バイト数を受信して受信完了
      - undefined : 追加データを要求
      - Error : エラー発生時のエラー情報
    @return {Promise}
      Promiseオブジェクト
    @return {ArrayBuffer} return.PromiseValue
      受信データ
     */

    BaseComm.prototype.transData = function(txdata, estimator) {
      var byte, dst, j, len, len1, src;
      if (txdata) {
        src = new Uint8Array(txdata);
        dst = new Uint8Array(txdata.byteLength * 2);
        len = 0;
        for (j = 0, len1 = src.length; j < len1; j++) {
          byte = src[j];
          if (byte === 0x3a || byte === 0x3d) {
            dst[len] = 0x3d;
            len += 1;
            byte ^= 0x20;
          }
          dst[len] = byte;
          len += 1;
        }
        txdata = dst.buffer.slice(0, len);
      }
      return this._transSerial(txdata, estimator);
    };


    /**
    @private
    @method
      ログの出力
    @param {number} lvl
      詳細度(0で常に出力。値が大きいほど詳細なメッセージを指す)
    @param {string} func
      関数名
    @param {string} msg
      メッセージ
    @param {Object} [data]
      任意のデータ
    @return {undefined}
     */

    BaseComm.prototype._log = function(lvl, func, msg, data) {
      if (this.constructor.verbosity >= lvl) {
        Canarium._log("BaseComm", func, msg, data);
      }
    };


    /**
    @private
    @method
      シリアル通信の送受信を行う
    @param {ArrayBuffer/null} txdata
      送信するデータ(nullの場合は受信のみ)
    @param {function(ArrayBuffer,number):number/undefined/Error} [estimator]
      受信完了まで繰り返し呼び出される受信処理関数。
      引数は受信データ全体と、今回の呼び出しで追加されたデータのオフセット。
      省略時は送信のみで完了とする。戻り値の解釈は以下の通り。
    
      - number : 指定バイト数を受信して受信完了
      - undefined : 追加データを要求
      - Error : エラー発生時のエラー情報
    @return {Promise}
      Promiseオブジェクト
    @return {ArrayBuffer} return.PromiseValue
      受信したデータ(指定バイト数分)
     */

    BaseComm.prototype._transSerial = function(txdata, estimator) {
      var promise, txsize, x;
      if (this._connection == null) {
        return Promise.reject(Error("Not connected"));
      }
      if (this._receiver != null) {
        return Promise.reject(Error("Operation is in progress"));
      }
      promise = new Promise((function(_this) {
        return function(resolve, reject) {
          return _this._receiver = function(rxdata, error) {
            var newArray, offset, ref1, result;
            if (rxdata != null) {
              offset = ((ref1 = _this._rxBuffer) != null ? ref1.byteLength : void 0) || 0;
              newArray = new Uint8Array(offset + rxdata.byteLength);
              if (_this._rxBuffer != null) {
                newArray.set(new Uint8Array(_this._rxBuffer));
              }
              newArray.set(new Uint8Array(rxdata), offset);
              _this._rxBuffer = newArray.buffer;
              result = estimator(_this._rxBuffer, offset);
            } else {
              result = error;
            }
            if (result instanceof Error) {
              _this._rxBuffer = null;
              _this._receiver = null;
              return reject(result);
            }
            if (result != null) {
              rxdata = _this._rxBuffer.slice(0, result);
              _this._rxBuffer = _this._rxBuffer.slice(result);
              _this._receiver = null;
              return resolve(rxdata);
            }
          };
        };
      })(this));
      txsize = (txdata != null ? txdata.byteLength : void 0) || 0;
      return ((function() {
        var j, ref1, ref2, results;
        results = [];
        for (x = j = 0, ref1 = txsize, ref2 = SERIAL_TX_MAX_LENGTH; ref2 > 0 ? j < ref1 : j > ref1; x = j += ref2) {
          results.push(x);
        }
        return results;
      })()).reduce((function(_this) {
        return function(sequence, pos) {
          return sequence.then(function() {
            var data, size;
            data = txdata.slice(pos, pos + SERIAL_TX_MAX_LENGTH);
            size = data.byteLength;
            return _this._connection.write(data).then(function() {
              return _this._log(1, "_transSerial", "sent", new Uint8Array(data));
            }).then(function() {
              if (!(SUCCESSIVE_TX_WAIT_MS > 0)) {
                return;
              }
              return waitPromise(SUCCESSIVE_TX_WAIT_MS);
            });
          });
        };
      })(this), Promise.resolve()).then((function(_this) {
        return function() {
          if (estimator == null) {
            _this._receiver = null;
            return new ArrayBuffer(0);
          }
          _this._log(1, "_transSerial", "wait", promise);
          return promise;
        };
      })(this));
    };

    return BaseComm;

  })();


  /**
  @class Canarium.BaseComm.SerialWrapper
    シリアル通信のラッパ(Chrome/NodeJS両対応用)
  @uses chrome.serial
  @uses SerialPort
   */

  Canarium.BaseComm.SerialWrapper = (function() {
    null;

    /**
    @property {function():undefined} onClosed
      ポートが閉じられたときに呼び出されるコールバック関数
      (不意の切断とclose()呼び出しのどちらで閉じても呼び出される)
     */

    /**
    @property {function(ArrayBuffer):undefined} onReceived
      データを受信したときに呼び出されるコールバック関数
      (もし登録されていない場合、受信したデータは破棄される)
     */
    var SEND_RETRY_INTERVAL, SerialPort, cidMap;

    if (IS_NODEJS) {
      SerialPort = require("serialport");
    }

    if (IS_CHROME) {
      cidMap = {};
    }

    SEND_RETRY_INTERVAL = 50;


    /**
    @private
    @property {number} SEND_RETRY_INTERVAL
      データが送信しきれなかった場合に続きを再送信するまでの待ち時間
      (ms単位、Chromeのみ)
     */


    /**
    @static
    @method
      ポートを列挙する
    @return {Promise}
      Promiseオブジェクト
    @return {Object[]} return.PromiseValue
      ポート情報の配列
    @return {string} return.PromiseValue.path
      パス (必ず格納される)
    @return {string} return.PromiseValue.manufacturer
      製造者 (環境によってはundefinedになりうる)
    @return {string} return.PromiseValue.serialNumber
      シリアル番号 (環境によってはundefinedになりうる)
    @return {string} return.PromiseValue.vendorId
      Vendor ID (環境によってはundefinedになりうる)
    @return {string} return.PromiseValue.productId
      Product ID (環境によってはundefinedになりうる)
     */

    SerialWrapper.list = IS_CHROME ? (function() {
      return new Promise((function(_this) {
        return function(resolve, reject) {
          return chrome.serial.getDevices(function(ports) {
            var port;
            return resolve((function() {
              var j, len1, results;
              results = [];
              for (j = 0, len1 = ports.length; j < len1; j++) {
                port = ports[j];
                results.push({
                  path: "" + port.path,
                  manufacturer: "" + port.displayName,
                  serialNumber: void 0,
                  vendorId: "" + port.vendorId,
                  productId: "" + port.productId
                });
              }
              return results;
            })());
          });
        };
      })(this));
    }) : IS_NODEJS ? (function() {
      return new Promise((function(_this) {
        return function(resolve, reject) {
          return SerialPort.list(function(error, ports) {
            var port;
            if (error != null) {
              return reject(Error(error));
            }
            return resolve((function() {
              var j, len1, results;
              results = [];
              for (j = 0, len1 = ports.length; j < len1; j++) {
                port = ports[j];
                if ((port.pnpId != null) || (port.locationId != null)) {
                  results.push({
                    path: "" + port.comName,
                    manufacturer: "" + port.manufacturer,
                    serialNumber: "" + port.serialNumber,
                    vendorId: "" + port.vendorId,
                    productId: "" + port.productId
                  });
                }
              }
              return results;
            })());
          });
        };
      })(this));
    }) : void 0;


    /**
    @method constructor
      コンストラクタ
    @param {string} _path
      接続先ポートのパス
    @param {Object} _options
      接続時のオプション
    @param {number} [_options.baudRate=115200]
      ボーレート
    @param {number} [_options.dataBits=8]
      データのビット幅
    @param {number} [_options.stopBits=1]
      ストップビット幅
     */

    function SerialWrapper(_path, _options) {
      var base, base1, base2;
      this._path = _path;
      this._options = _options;
      this._options || (this._options = {});
      (base = this._options).baudRate || (base.baudRate = 115200);
      (base1 = this._options).dataBits || (base1.dataBits = 8);
      (base2 = this._options).stopBits || (base2.stopBits = 1);
      this.onClosed = void 0;
      this.onReceived = void 0;
      this.SEND_RETRY_INTERVAL = SEND_RETRY_INTERVAL;
      return;
    }


    /**
    @method
      接続する
    @return {Promise}
      Promiseオブジェクト
    @return {undefined} return.PromiseValue
     */

    SerialWrapper.prototype.open = IS_CHROME ? (function() {
      return new Promise((function(_this) {
        return function(resolve, reject) {
          var opts;
          opts = {
            bitrate: _this._options.baudRate,
            receiveTimeout: 500
          };
          return chrome.serial.connect(_this._path, opts, function(connectionInfo) {
            if (connectionInfo == null) {
              return reject(Error(chrome.runtime.lastError.message));
            }
            _this._cid = connectionInfo.connectionId;
            cidMap[_this._cid] = _this;
            return resolve();
          });
        };
      })(this));
    }) : IS_NODEJS ? (function() {
      return new Promise((function(_this) {
        return function(resolve, reject) {
          var k, opts, ref1, v;
          if (_this._sp == null) {
            opts = {
              autoOpen: false
            };
            ref1 = _this._options;
            for (k in ref1) {
              v = ref1[k];
              opts[k] = v;
            }
            _this._sp = new SerialPort(_this._path, opts, function() {});
            _this._sp.on("data", function(data) {
              return _this._dataHandler(data);
            });
            _this._sp.on("disconnect", function() {
              return _this._closeHandler();
            });
          }
          return _this._sp.open(function(error) {
            var a;
            if (error != null) {
              return reject(Error(error));
            }
            return resolve();
            a = {};
            return a.id = global.setInterval((function() {
              if (_this._sp) {
                return _this._sp.drain();
              }
              return clearInterval(a.id);
            }), 500);
          });
        };
      })(this));
    }) : void 0;


    /**
    @method
      データの書き込み(送信)
    @param {ArrayBuffer} data
      送信するデータ
    @return {Promise}
      Promiseオブジェクト
    @return {undefined} return.PromiseValue
     */

    SerialWrapper.prototype.write = IS_CHROME ? (function(data) {
      return new Promise((function(_this) {
        return function(resolve, reject) {
          var retry;
          if (_this._cid == null) {
            return reject(Error("disconnected"));
          }
          retry = function() {
            if (data.byteLength === 0) {
              return resolve();
            }
            return chrome.serial.send(_this._cid, data, function(sendInfo) {
              if (sendInfo.error != null) {
                return reject(Error(sendInfo.error));
              }
              if (sendInfo.bytesSent >= data.byteLength) {
                return resolve();
              }
              data = data.slice(sendInfo.bytesSent);
              return setTimeout(retry, _this.SEND_RETRY_INTERVAL);
            });
          };
          return retry();
        };
      })(this));
    }) : IS_NODEJS ? (function(data) {
      return new Promise((function(_this) {
        return function(resolve, reject) {
          if (_this._sp == null) {
            return reject(Error("disconnected"));
          }
          return _this._sp.write(new Buffer(new Uint8Array(data)), function(error) {
            if (error != null) {
              return reject(error);
            }
            return _this._sp.drain(resolve);
          });
        };
      })(this));
    }) : void 0;


    /**
    @method
      接続を一時停止状態にする
    @return {Promise}
      Promiseオブジェクト
    @return {undefined} return.PromiseValue
     */

    SerialWrapper.prototype.pause = IS_CHROME ? (function() {
      return new Promise((function(_this) {
        return function(resolve, reject) {
          if (_this._cid == null) {
            return reject(Error("disconnected"));
          }
          return chrome.serial.setPaused(_this._cid, true, function() {
            return resolve();
          });
        };
      })(this));
    }) : IS_NODEJS ? (function() {
      return new Promise((function(_this) {
        return function(resolve, reject) {
          if (_this._sp == null) {
            return reject(Error("disconnected"));
          }
          _this._sp.pause();
          return resolve();
        };
      })(this));
    }) : void 0;


    /**
    @method
      接続の一時停止を解除する
    @return {Promise}
      Promiseオブジェクト
    @return {undefined} return.PromiseValue
     */

    SerialWrapper.prototype.resume = IS_CHROME ? (function() {
      return new Promise((function(_this) {
        return function(resolve, reject) {
          if (_this._cid == null) {
            return reject(Error("disconnected"));
          }
          return chrome.serial.setPaused(_this._cid, false, function() {
            return resolve();
          });
        };
      })(this));
    }) : IS_NODEJS ? (function() {
      return new Promise((function(_this) {
        return function(resolve, reject) {
          if (_this._sp == null) {
            return reject(Error("disconnected"));
          }
          _this._sp.resume();
          return resolve();
        };
      })(this));
    }) : void 0;


    /**
    @method
      送受信待ちのバッファを破棄する(送受信データが欠落する可能性がある)
    @return {Promise}
      Promiseオブジェクト
    @return {undefined} return.PromiseValue
     */

    SerialWrapper.prototype.flush = IS_CHROME ? (function() {
      return new Promise((function(_this) {
        return function(resolve, reject) {
          if (_this._cid == null) {
            return reject(Error("disconnected"));
          }
          return chrome.serial.flush(_this._cid, function(result) {
            if (!result) {
              return reject(Error("unknown_error"));
            }
            return resolve();
          });
        };
      })(this));
    }) : IS_NODEJS ? (function() {
      return new Promise((function(_this) {
        return function(resolve, reject) {
          if (_this._sp == null) {
            return reject(Error("disconnected"));
          }
          return _this._sp.flush(function(error) {
            if (error != null) {
              return reject(error);
            }
            return resolve();
          });
        };
      })(this));
    }) : void 0;


    /**
    @method
      送受信待ちのバッファを強制的に吐き出す(送受信データは欠落しない)
    @return {Promise}
      Promiseオブジェクト
    @return {undefined} return.PromiseValue
     */

    SerialWrapper.prototype.drain = IS_CHROME ? (function() {
      return new Promise((function(_this) {
        return function(resolve, reject) {
          if (_this._cid == null) {
            return reject(Error("disconnected"));
          }
          return resolve();
        };
      })(this));
    }) : IS_NODEJS ? (function() {
      return new Promise((function(_this) {
        return function(resolve, reject) {
          if (_this._sp == null) {
            return reject(Error("disconnected"));
          }
          return _this._sp.drain(function(error) {
            if (error != null) {
              return reject(error);
            }
            return resolve();
          });
        };
      })(this));
    }) : void 0;


    /**
    @method
      切断する
    @return {Promise}
      Promiseオブジェクト
    @return {undefined} return.PromiseValue
     */

    SerialWrapper.prototype.close = IS_CHROME ? (function() {
      return new Promise((function(_this) {
        return function(resolve, reject) {
          if (_this._cid == null) {
            return reject(Error("disconnected"));
          }
          return chrome.serial.disconnect(_this._cid, function(result) {
            var base;
            if (!result) {
              return reject(Error("unknown_error"));
            }
            delete cidMap[_this._cid];
            _this._cid = null;
            if (typeof (base = _this.onClosed) === "function") {
              base();
            }
            return resolve();
          });
        };
      })(this));
    }) : IS_NODEJS ? (function() {
      return new Promise((function(_this) {
        return function(resolve, reject) {
          if (_this._sp == null) {
            return reject(Error("disconnected"));
          }
          return _this._sp.close(function(error) {
            var base;
            if (error != null) {
              return reject(error);
            }
            _this._sp.fd = void 0;
            _this._sp = null;
            if (typeof (base = _this.onClosed) === "function") {
              base();
            }
            return resolve();
          });
        };
      })(this));
    }) : void 0;


    /**
    @private
    @method
      データ受信ハンドラ(NodeJSのみ)
    @param {Buffer} data
      受信したデータ
    @return {undefined}
     */

    SerialWrapper.prototype._dataHandler = IS_NODEJS ? (function(data) {
      var base;
      if (typeof (base = this.onReceived) === "function") {
        base(new Uint8Array(data).buffer);
      }
    }) : void 0;


    /**
    @private
    @method
      切断検知ハンドラ(NodeJSのみ)
    @return {undefined}
     */

    SerialWrapper.prototype._closeHandler = IS_NODEJS ? (function() {
      this.close()["catch"]((function(_this) {
        return function() {};
      })(this));
    }) : void 0;


    /**
    @private
    @static
    @method
      データ受信ハンドラ(chromeのみ)
    @param {Object} info
      受信情報
    @param {number} info.connectionId
      受信したコネクションの番号
    @param {ArrayBuffer} info.data
      受信したデータ
    @return {undefined}
     */

    SerialWrapper._receiveHandler = IS_CHROME ? (function(info) {
      var base, self;
      self = cidMap[info.connectionId];
      if (self == null) {
        return;
      }
      if (typeof (base = self.onReceived) === "function") {
        base(info.data);
      }
    }) : void 0;


    /**
    @private
    @static
    @method
      エラー受信ハンドラ(chromeのみ)
    @param {Object} info
      受信情報
    @param {number} info.connectionId
      エラーが発生したコネクションの番号
    @param {string} info.error
      発生したエラーの種類
    @return {undefined}
     */

    SerialWrapper._receiveErrorHandler = IS_CHROME ? (function(info) {
      var self;
      self = cidMap[info.connectionId];
      if (self == null) {
        return;
      }
      switch (info.error) {
        case "timeout":
          null;
          break;
        case "disconnected":
        case "device_lost":
        case "break":
        case "frame_error":
        case "system_error":
          self.close();
      }
    }) : void 0;

    if (IS_CHROME) {
      chrome.serial.onReceive.addListener(SerialWrapper._receiveHandler);
    }

    if (IS_CHROME) {
      chrome.serial.onReceiveError.addListener(SerialWrapper._receiveErrorHandler);
    }

    return SerialWrapper;

  })();

  dump = null;


  /**
  @class Canarium.I2CComm
    PERIDOTボードI2C通信クラス
  @uses Canarium.BaseComm
   */

  Canarium.I2CComm = (function() {
    null;

    /**
    @static
    @property {number}
      デバッグ出力の細かさ(0で出力無し)
     */
    var I2C_TIMEOUT_MS;

    I2CComm.verbosity = 0;


    /**
    @private
    @property {Canarium.BaseComm} _base
      下位層通信クラスのインスタンス
     */


    /**
    @private
    @static
    @cfg {number}
      I2C通信のタイムアウト時間
    @readonly
     */

    I2C_TIMEOUT_MS = 1000;


    /**
    @method constructor
      コンストラクタ
    @param {Canarium.BaseComm} _base
      下位層通信クラスのインスタンス
     */

    function I2CComm(_base) {
      this._base = _base;
      return;
    }


    /**
    @method
      スタートコンディションの送信
    @param {function(boolean,Error=)} [callback]
      コールバック関数(省略時は戻り値としてPromiseオブジェクトを返す)
    @return {undefined/Promise}
      戻り値なし(callback指定時)、または、Promiseオブジェクト(callback省略時)
     */

    I2CComm.prototype.start = function(callback) {
      var timeLimit;
      if (callback != null) {
        return invokeCallback(callback, this.start());
      }
      timeLimit = void 0;
      return Promise.resolve().then((function(_this) {
        return function() {
          _this._log(1, "start", "(start condition)");
          timeLimit = new TimeLimit(I2C_TIMEOUT_MS);
          return tryPromise(timeLimit.left, function() {
            return _this._base.transCommand(0x3b).then(function(response) {
              if ((response & 0x30) !== 0x30) {
                return Promise.reject();
              }
            });
          });
        };
      })(this)).then((function(_this) {
        return function() {
          return _this._base.transCommand(0x1b);
        };
      })(this)).then((function(_this) {
        return function() {
          return _this._base.transCommand(0x0b);
        };
      })(this)).then((function(_this) {
        return function() {};
      })(this));
    };


    /**
    @method
      ストップコンディションの送信
      (必ずSCL='L'が先行しているものとする)
    @param {function(boolean,Error=)} [callback]
      コールバック関数(省略時は戻り値としてPromiseオブジェクトを返す)
    @return {undefined/Promise}
      戻り値なし(callback指定時)、または、Promiseオブジェクト(callback省略時)
     */

    I2CComm.prototype.stop = function(callback) {
      var timeLimit;
      if (callback != null) {
        return invokeCallback(callback, this.stop());
      }
      timeLimit = void 0;
      return Promise.resolve().then((function(_this) {
        return function() {
          _this._log(1, "stop", "(stop condition)");
          timeLimit = new TimeLimit(I2C_TIMEOUT_MS);
          return _this._base.transCommand(0x0b);
        };
      })(this)).then((function(_this) {
        return function() {
          return tryPromise(timeLimit.left, function() {
            return _this._base.transCommand(0x1b).then(function(response) {
              if ((response & 0x30) !== 0x10) {
                return Promise.reject();
              }
            });
          });
        };
      })(this)).then((function(_this) {
        return function() {
          return tryPromise(timeLimit.left, function() {
            return _this._base.transCommand(0x3b).then(function(response) {
              if ((response & 0x30) !== 0x30) {
                return Promise.reject();
              }
            });
          });
        };
      })(this)).then((function(_this) {
        return function() {
          if (_this._base.sendImmediate) {
            return;
          }
          return _this._base.transCommand(0x39);
        };
      })(this)).then((function(_this) {
        return function() {};
      })(this));
    };


    /**
    @method
      バイトリード
      (必ずSCL='L'が先行しているものとする)
    @param {boolean} ack
      ACK返却の有無(true:ACK, false:NAK)
    @param {function(boolean,number/Error=)} [callback]
      コールバック関数(省略時は戻り値としてPromiseオブジェクトを返す)
    @return {undefined/Promise}
      戻り値なし(callback指定時)、または、Promiseオブジェクト(callback省略時)
    @return {number} return.PromiseValue
      読み込みデータ(0～255)
     */

    I2CComm.prototype.read = function(ack, callback) {
      var readData, timeLimit;
      if (callback != null) {
        return invokeCallback(callback, this.read(ack));
      }
      ack = !!ack;
      timeLimit = void 0;
      readData = 0x00;
      return Promise.resolve().then((function(_this) {
        return function() {
          timeLimit = new TimeLimit(I2C_TIMEOUT_MS);
          return [7, 6, 5, 4, 3, 2, 1, 0].reduce(function(promise, bitNum) {
            return promise.then(function() {
              return tryPromise(timeLimit.left, function() {
                return _this._readBit();
              }, 1);
            }).then(function(bit) {
              _this._log(2, "read", "bit#" + bitNum + "=" + bit);
              return readData |= bit << bitNum;
            });
          }, Promise.resolve());
        };
      })(this)).then((function(_this) {
        return function() {
          return tryPromise(timeLimit.left, function() {
            _this._log(2, "read", ack ? "ACK" : "NAK");
            return _this._writeBit(ack ? 0 : 1);
          }, 1);
        };
      })(this)).then((function(_this) {
        return function() {
          _this._log(1, "read", "data=0x" + (readData.toString(16)));
          return readData;
        };
      })(this));
    };


    /**
    @method
      バイトライト
      (必ずSCL='L'が先行しているものとする)
    @param {number} writebyte
      書き込むデータ(0～255)
    @param {function(boolean,number/Error=)} [callback]
      コールバック関数(省略時は戻り値としてPromiseオブジェクトを返す)
    @return {undefined/Promise}
      戻り値なし(callback指定時)、または、Promiseオブジェクト(callback省略時)
    @return {boolean} return.PromiseValue
      ACK受信の有無(true:ACK, false:NAK)
     */

    I2CComm.prototype.write = function(writebyte, callback) {
      var timeLimit;
      if (callback != null) {
        return invokeCallback(callback, this.write(writebyte));
      }
      writebyte = parseInt(writebyte);
      timeLimit = void 0;
      return Promise.resolve().then((function(_this) {
        return function() {
          _this._log(1, "write", "data=0x" + (writebyte.toString(16)));
          timeLimit = new TimeLimit(I2C_TIMEOUT_MS);
          return [7, 6, 5, 4, 3, 2, 1, 0].reduce(function(sequence, bitNum) {
            var bit;
            bit = (writebyte >>> bitNum) & 1;
            return sequence.then(function() {
              _this._log(2, "write", "bit#" + bitNum + "=" + bit);
              return tryPromise(timeLimit.left, function() {
                return _this._writeBit(bit);
              }, 1);
            });
          }, Promise.resolve());
        };
      })(this)).then((function(_this) {
        return function() {
          return tryPromise(timeLimit.left, function() {
            return _this._readBit();
          }, 1);
        };
      })(this)).then((function(_this) {
        return function(bit) {
          var ack;
          ack = bit === 0;
          _this._log(2, "write", ack ? "ACK" : "NAK");
          return ack;
        };
      })(this));
    };


    /**
    @private
    @method
      ログの出力
    @param {number} lvl
      詳細度(0で常に出力。値が大きいほど詳細なメッセージを指す)
    @param {string} func
      関数名
    @param {string} msg
      メッセージ
    @param {Object} [data]
      任意のデータ
    @return {void}
     */

    I2CComm.prototype._log = function(lvl, func, msg, data) {
      if (this.constructor.verbosity >= lvl) {
        Canarium._log("I2CComm", func, msg, data);
      }
    };


    /**
    @private
    @method
      1ビットリード
      (必ずSCL='L'が先行しているものとする)
    @return {Promise}
      Promiseオブジェクト
    @return {0/1} return.PromiseValue
      読み出しビット値
     */

    I2CComm.prototype._readBit = function() {
      var bit, timeLimit;
      timeLimit = void 0;
      bit = 0;
      return Promise.resolve().then((function(_this) {
        return function() {
          timeLimit = new TimeLimit(I2C_TIMEOUT_MS);
          _this._log(3, "_readBit", "setup,SCL->HiZ");
          return tryPromise(timeLimit.left, function() {
            return _this._base.transCommand(0x3b).then(function(response) {
              if ((response & 0x10) !== 0x10) {
                return Promise.reject();
              }
              if ((response & 0x20) === 0x20) {
                return bit = 1;
              }
            });
          });
        };
      })(this)).then((function(_this) {
        return function() {
          _this._log(3, "_readBit", "SCL->L");
          return _this._base.transCommand(0x2b);
        };
      })(this)).then((function(_this) {
        return function() {
          return bit;
        };
      })(this));
    };


    /**
    @private
    @method
      1ビットライト
      (必ずSCL='L'が先行しているものとする)
    @return {0/1} bit
      書き込みビット値
    @return {Promise}
      Promiseオブジェクト
     */

    I2CComm.prototype._writeBit = function(bit) {
      var timeLimit;
      timeLimit = void 0;
      bit = (bit !== 0 ? 1 : 0) << 5;
      return Promise.resolve().then((function(_this) {
        return function() {
          timeLimit = new TimeLimit(I2C_TIMEOUT_MS);
          _this._log(3, "_writeBit", "setup");
          return _this._base.transCommand(0x0b | bit);
        };
      })(this)).then((function(_this) {
        return function() {
          _this._log(3, "_writeBit", "SCL->HiZ");
          return tryPromise(timeLimit.left, function() {
            return _this._base.transCommand(0x1b | bit).then(function(response) {
              if ((response & 0x10) !== 0x10) {
                return Promise.reject();
              }
            });
          });
        };
      })(this)).then((function(_this) {
        return function() {
          _this._log(3, "_writeBit", "SCL->L");
          return _this._base.transCommand(0x2b);
        };
      })(this)).then((function(_this) {
        return function() {};
      })(this));
    };

    return I2CComm;

  })();


  /**
  @class Canarium.AvsPackets
    PERIDOTボードAvalon-STパケット層通信クラス
  @uses Canarium.BaseComm
   */

  Canarium.AvsPackets = (function() {
    null;

    /**
    @property base
    @inheritdoc #_base
    @readonly
     */
    AvsPackets.property("base", {
      get: function() {
        return this._base;
      }
    });


    /**
    @static
    @property {number}
      デバッグ出力の細かさ(0で出力無し)
     */

    AvsPackets.verbosity = 0;


    /**
    @private
    @property {Canarium.BaseComm} _base
      下位層通信クラスのインスタンス
     */


    /**
    @method constructor
      コンストラクタ
    @param {Canarium.BaseComm} _base
      下位層通信クラスのインスタンス
     */

    function AvsPackets(_base) {
      this._base = _base;
      return;
    }


    /**
    @method
      Avalon-STパケットを送受信する。
      チャネル選択およびSOP/EOPは自動的に付加される。
      現時点では、受信データに複数のチャネルがインタリーブすることは認めない。
    @param {number} channel
      チャネル番号(0～255)
    @param {ArrayBuffer}  txdata
      送信するパケットデータ
    @param {number} rxsize
      受信するパケットのバイト数
    @return {Promise}
      Promiseオブジェクト
    @return {ArrayBuffer} return.PromiseValue
      受信したデータ
     */

    AvsPackets.prototype.transPacket = function(channel, txdata, rxsize) {
      var byte, dst, eopFinder, header, j, len, len1, pushWithEscape, ref1, src, totalRxLen;
      pushWithEscape = function(array, pos, byte) {
        if ((0x7a <= byte && byte <= 0x7d)) {
          array[pos++] = 0x7d;
          array[pos++] = byte ^ 0x20;
          return pos;
        }
        array[pos++] = byte;
        return pos;
      };
      channel &= 0xff;
      src = new Uint8Array(txdata);
      dst = new Uint8Array(txdata.byteLength * 2 + 5);
      len = 0;
      dst[len++] = 0x7c;
      len = pushWithEscape(dst, len, channel);
      dst[len++] = 0x7a;
      header = dst.subarray(0, len);
      ref1 = src.subarray(0, src.length - 1);
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        byte = ref1[j];
        len = pushWithEscape(dst, len, byte);
      }
      dst[len++] = 0x7b;
      len = pushWithEscape(dst, len, src[src.length - 1]);
      txdata = dst.buffer.slice(0, len);
      totalRxLen = rxsize + header.length + 1;
      this._log(1, "transPacket", "begin", {
        source: src,
        encoded: new Uint8Array(txdata)
      });
      eopFinder = (function(_this) {
        return function(rxdata, offset) {
          var array, l, pos, ref2, ref3;
          array = new Uint8Array(rxdata);
          for (pos = l = ref2 = offset, ref3 = array.length; ref2 <= ref3 ? l < ref3 : l > ref3; pos = ref2 <= ref3 ? ++l : --l) {
            if ((array[pos - 1] === 0x7b && array[pos - 0] !== 0x7d) || (array[pos - 2] === 0x7b && array[pos - 1] === 0x7d)) {
              return pos + 1;
            }
          }
        };
      })(this);
      return this._base.transData(txdata, eopFinder).then((function(_this) {
        return function(rxdata) {
          var i, l, len2, m, pos, ref2, xor;
          src = new Uint8Array(rxdata);
          _this._log(1, "transPacket", "recv", {
            encoded: src
          });
          for (i = l = 0, ref2 = header.length; 0 <= ref2 ? l < ref2 : l > ref2; i = 0 <= ref2 ? ++l : --l) {
            if (src[i] !== header[i]) {
              return Promise.reject(Error("Illegal packetize control bytes"));
            }
          }
          src = src.subarray(header.length);
          dst = new Uint8Array(rxsize);
          pos = 0;
          xor = 0x00;
          for (m = 0, len2 = src.length; m < len2; m++) {
            byte = src[m];
            if (pos === rxsize) {
              return Promise.reject(Error("Received data is too large"));
            }
            if (byte === 0x7b) {
              continue;
            }
            if (byte === 0x7d) {
              xor = 0x20;
            } else {
              dst[pos++] = byte ^ xor;
              xor = 0x00;
            }
          }
          if (pos < rxsize) {
            return Promise.reject(Error("Received data is too small"));
          }
          _this._log(1, "transPacket", "end", {
            decoded: dst
          });
          return dst.buffer;
        };
      })(this));
    };


    /**
    @private
    @method
      ログの出力
    @param {number} lvl
      詳細度(0で常に出力。値が大きいほど詳細なメッセージを指す)
    @param {string} func
      関数名
    @param {string} msg
      メッセージ
    @param {Object} [data]
      任意のデータ
    @return {undefined}
     */

    AvsPackets.prototype._log = function(lvl, func, msg, data) {
      if (this.constructor.verbosity >= lvl) {
        Canarium._log("AvsPackets", func, msg, data);
      }
    };

    return AvsPackets;

  })();


  /**
  @class Canarium.AvmTransactions
    PERIDOTボードAvalon-MMトランザクション層通信クラス
  @uses Canarium.AvsPackets
   */

  Canarium.AvmTransactions = (function() {
    null;

    /**
    @property base
    @inheritdoc Canarium.AvsPackets#_base
    @readonly
     */
    var AVM_TRANS_MAX_BYTES, SWI_BASE_ADDR;

    AvmTransactions.property("base", {
      get: function() {
        return this._avs.base;
      }
    });


    /**
    @property {number} swiBase
      ホスト通信用ペリフェラル(SWI)のベースアドレス
     */

    AvmTransactions.property("swiBase", {
      get: function() {
        return this._swiBase;
      },
      set: function(v) {
        return this._swiBase = parseInt(v);
      }
    });


    /**
    @static
    @property {number}
      デバッグ出力の細かさ(0で出力無し)
     */

    AvmTransactions.verbosity = 0;


    /**
    @private
    @property {Canarium.AvsPackets} _avs
      Avalon-STパケット層通信クラスのインスタンス
     */


    /**
    @private
    @property {number} _channel
      Avalon Packets to Transactions Converterのチャネル番号
     */


    /**
    @private
    @property {Promise} _lastAction
      キューされている動作の最後尾を示すPromiseオブジェクト
     */


    /**
    @private
    @static
    @cfg {number} SWI_BASE_ADDR = 0x10000000
      ホスト通信用ペリフェラル(SWI)のベースアドレス
    @readonly
     */

    SWI_BASE_ADDR = 0x10000000;


    /**
    @private
    @static
    @cfg {number}
      1回のトランザクションで読み書きできる最大バイト数
    @readonly
     */

    AVM_TRANS_MAX_BYTES = 32768;


    /**
    @method constructor
      コンストラクタ
    @param {Canarium.AvsPackets} _avs
      Avalon-STパケット層通信クラスのインスタンス
    @param {number} _channel
      パケットのチャネル番号
     */

    function AvmTransactions(_avs, _channel) {
      this._avs = _avs;
      this._channel = _channel;
      this._swiBase = SWI_BASE_ADDR;
      this._lastAction = Promise.resolve();
      return;
    }


    /**
    @method
      AvalonMMメモリリード(IORD_DIRECT)
    @param {number} address
      読み込み元アドレス(バイト単位)
    @param {number} bytenum
      読み込むバイト数
    @param {function(boolean,ArrayBuffer/Error)} [callback]
      コールバック関数(省略時は戻り値としてPromiseオブジェクトを返す)
    @return {undefined/Promise}
      戻り値なし(callback指定時)、または、Promiseオブジェクト
    @return {ArrayBuffer} return.PromiseValue
      受信したデータ
     */

    AvmTransactions.prototype.read = function(address, bytenum, callback) {
      if (callback != null) {
        return invokeCallback(callback, this.read(address, bytenum));
      }
      return this._avs.base.assertConnection().then((function(_this) {
        return function() {
          return _this._queue(function() {
            var dest, x;
            _this._log(1, "read", "begin(address=" + (hexDump(address)) + ")");
            if (!_this._avs.base.configured) {
              return Promise.reject(Error("Device is not configured"));
            }
            dest = new Uint8Array(bytenum);
            return ((function() {
              var j, ref1, ref2, results;
              results = [];
              for (x = j = 0, ref1 = bytenum, ref2 = AVM_TRANS_MAX_BYTES; ref2 > 0 ? j < ref1 : j > ref1; x = j += ref2) {
                results.push(x);
              }
              return results;
            })()).reduce(function(sequence, pos) {
              return sequence.then(function() {
                var partialSize;
                partialSize = Math.min(bytenum - pos, AVM_TRANS_MAX_BYTES);
                _this._log(2, "read", "partial(offset=" + (hexDump(pos)) + ",size=" + (hexDump(partialSize)) + ")");
                return _this._trans(0x14, address + pos, void 0, partialSize).then(function(partialData) {
                  return dest.set(new Uint8Array(partialData), pos);
                });
              });
            }, Promise.resolve()).then(function() {
              _this._log(1, "read", "end", dest);
              return dest.buffer;
            });
          });
        };
      })(this));
    };


    /**
    @method
      AvalonMMメモリライト(IOWR_DIRECT)
    @param {number} address
      書き込み先アドレス(バイト単位)
    @param {ArrayBuffer} writedata
      書き込むデータ
    @param {function(boolean,Error=)} [callback]
      コールバック関数(省略時は戻り値としてPromiseオブジェクトを返す)
    @return {undefined/Promise}
      戻り値なし(callback指定時)、または、Promiseオブジェクト
     */

    AvmTransactions.prototype.write = function(address, writedata, callback) {
      var src;
      if (callback != null) {
        return invokeCallback(callback, this.write(address, writedata));
      }
      src = new Uint8Array(writedata.slice(0));
      return this._avs.base.assertConnection().then((function(_this) {
        return function() {
          return _this._queue(function() {
            var x;
            _this._log(1, "write", "begin(address=" + (hexDump(address)) + ")", src);
            if (!_this._avs.base.configured) {
              return Promise.reject(Error("Device is not configured"));
            }
            return ((function() {
              var j, ref1, ref2, results;
              results = [];
              for (x = j = 0, ref1 = src.byteLength, ref2 = AVM_TRANS_MAX_BYTES; ref2 > 0 ? j < ref1 : j > ref1; x = j += ref2) {
                results.push(x);
              }
              return results;
            })()).reduce(function(sequence, pos) {
              return sequence.then(function() {
                var partialData;
                partialData = src.subarray(pos, pos + AVM_TRANS_MAX_BYTES);
                _this._log(2, "write", "partial(offset=" + (hexDump(pos)) + ")", partialData);
                return _this._trans(0x04, address + pos, partialData, void 0);
              });
            }, Promise.resolve()).then(function() {
              _this._log(1, "write", "end");
            });
          });
        };
      })(this));
    };


    /**
    @method
      AvalonMMペリフェラルリード(IORD)
    @param {number} address
      読み込み元ベースアドレス(バイト単位。ただし自動的に4バイトの倍数に切り捨てられる)
    @param {number} offset
      オフセット(4バイトワード単位)
    @param {function(boolean,number/Error)} [callback]
      コールバック関数(省略時は戻り値としてPromiseオブジェクトを返す)
    @return {undefined/Promise}
      戻り値なし(callback指定時)、または、Promiseオブジェクト
    @return {number} return.PromiseValue
      受信したデータ(リトルエンディアンの32-bit符号有り整数)
     */

    AvmTransactions.prototype.iord = function(address, offset, callback) {
      if (callback != null) {
        return invokeCallback(callback, this.iord(address, offset));
      }
      return this._avs.base.assertConnection().then((function(_this) {
        return function() {
          return _this._queue(function() {
            _this._log(1, "iord", "begin(address=" + (hexDump(address)) + "+" + offset + ")");
            if (!_this._avs.base.configured) {
              return Promise.reject(Error("Device is not configured"));
            }
            return _this._trans(0x10, (address & 0xfffffffc) + (offset << 2), void 0, 4).then(function(rxdata) {
              var readData, src;
              src = new Uint8Array(rxdata);
              readData = ((src[3] << 24) | (src[2] << 16) | (src[1] << 8) | (src[0] << 0)) >>> 0;
              _this._log(1, "iord", "end", readData);
              return readData;
            });
          });
        };
      })(this));
    };


    /**
    @method
      AvalonMMペリフェラルライト(IOWR)
    @param {number} address
      書き込み先ベースアドレス(バイト単位。ただし自動的に4バイトの倍数に切り捨てられる)
    @param {number} offset
      オフセット(4バイトワード単位)
    @param {number} writedata
      書き込むデータ(リトルエンディアン)
    @param {function(boolean,Error=)} [callback]
      コールバック関数(省略時は戻り値としてPromiseオブジェクトを返す)
    @return {undefined/Promise}
      戻り値なし(callback指定時)、または、Promiseオブジェクト
     */

    AvmTransactions.prototype.iowr = function(address, offset, writedata, callback) {
      if (callback != null) {
        return invokeCallback(callback, this.iowr(address, offset, writedata));
      }
      return this._avs.base.assertConnection().then((function(_this) {
        return function() {
          return _this._queue(function() {
            var src;
            _this._log(1, "iowr", "begin(address=" + (hexDump(address)) + "+" + offset + ")", writedata);
            if (!_this._avs.base.configured) {
              return Promise.reject(Error("Device is not configured"));
            }
            src = new Uint8Array(4);
            src[0] = (writedata >>> 0) & 0xff;
            src[1] = (writedata >>> 8) & 0xff;
            src[2] = (writedata >>> 16) & 0xff;
            src[3] = (writedata >>> 24) & 0xff;
            return _this._trans(0x00, (address & 0xfffffffc) + (offset << 2), src, void 0).then(function() {
              _this._log(1, "iowr", "end");
            });
          });
        };
      })(this));
    };


    /**
    @method
      AvalonMMオプション設定
    @param {Object} option
      オプション
    @param {boolean} option.fastAcknowledge
      即時応答ビットを立てるかどうか
    @param {boolean} option.forceConfigured
      コンフィグレーション済みとして扱うかどうか
    @param {function(boolean,Error=)} [callback]
      コールバック関数(省略時は戻り値としてPromiseオブジェクトを返す)
    @return {undefined/Promise}
      戻り値なし(callback指定時)、または、Promiseオブジェクト
     */

    AvmTransactions.prototype.option = function(option, callback) {
      if (callback != null) {
        return invokeCallback(callback, this.option(option));
      }
      return this._avs.base.assertConnection().then((function(_this) {
        return function() {
          return _this._queue(function() {
            return _this._avs.base.option(option);
          });
        };
      })(this));
    };


    /**
    @private
    @method
      非同期実行キューに追加する
    @param {function():Promise} action
      Promiseオブジェクトを返却する関数
    @return {Promise}
      Promiseオブジェクト
     */

    AvmTransactions.prototype._queue = function(action) {
      return new Promise((function(_this) {
        return function(resolve, reject) {
          return _this._lastAction = _this._lastAction.then(action).then(resolve, reject);
        };
      })(this));
    };


    /**
    @private
    @method
      ログの出力
    @param {number} lvl
      詳細度(0で常に出力。値が大きいほど詳細なメッセージを指す)
    @param {string} func
      関数名
    @param {string} msg
      メッセージ
    @param {Object} [data]
      任意のデータ
    @return {undefined}
     */

    AvmTransactions.prototype._log = function(lvl, func, msg, data) {
      if (this.constructor.verbosity >= lvl) {
        Canarium._log("AvmTransactions", func, msg, data);
      }
    };


    /**
    @private
    @method
      トランザクションの発行
    @param {number} transCode
      トランザクションコード
    @param {number} address
      アドレス
    @param {Uint8Array/undefined} txdata
      送信パケットに付加するデータ(受信時はundefined)
    @param {undefined/number}  rxsize
      受信するバイト数(送信時はundefined)
    @return {Promise}
      Promiseオブジェクト
    @return {ArrayBuffer} return.PromiseValue
      受信したデータ
     */

    AvmTransactions.prototype._trans = function(transCode, address, txdata, rxsize) {
      var len, pkt;
      len = (txdata != null ? txdata.byteLength : void 0) || rxsize;
      pkt = new Uint8Array(8 + ((txdata != null ? txdata.byteLength : void 0) || 0));
      pkt[0] = transCode;
      pkt[1] = 0x00;
      pkt[2] = (len >>> 8) & 0xff;
      pkt[3] = (len >>> 0) & 0xff;
      pkt[4] = (address >>> 24) & 0xff;
      pkt[5] = (address >>> 16) & 0xff;
      pkt[6] = (address >>> 8) & 0xff;
      pkt[7] = (address >>> 0) & 0xff;
      if (txdata) {
        pkt.set(txdata, 8);
      }
      this._log(2, "_trans", "send", pkt);
      return this._avs.transPacket(this._channel, pkt.buffer, rxsize || 4).then((function(_this) {
        return function(rxdata) {
          var res;
          _this._log(2, "_trans", "recv", new Uint8Array(rxdata));
          if (rxsize) {
            if (rxdata.byteLength !== rxsize) {
              return Promise.reject(Error("Received data length does not match"));
            }
            return rxdata;
          }
          res = new Uint8Array(rxdata);
          if (!(res[0] === pkt[0] ^ 0x80 && res[2] === pkt[2] && res[3] === pkt[3])) {
            return Promise.reject(Error("Illegal write response"));
          }
        };
      })(this));
    };

    return AvmTransactions;

  })();


  /**
  @class Canarium.RemoteError
    PERIDOTボード側のエラーを表現するクラス
   */

  Canarium.RemoteError = (function(superClass) {
    var MESSAGES, desc, name, num, ref1, v;

    extend(RemoteError, superClass);

    null;


    /**
    @property {number} code
      エラー番号(PERIDOTボード側システムのerrno値、またはJSON-RPC仕様で定義された値)
    @readonly
     */


    /**
    @property {string} message
      エラーメッセージ
    @readonly
     */


    /**
    @property {Object} data
      エラーの付属情報
    @readonly
     */

    MESSAGES = {
      "-32700": "Parse error",
      "-32600": "Invalid request",
      "-32601": "Method not found",
      "-32602": "Invalid params",
      "-32603": "Internal error"
    };

    ref1 = {
      EPERM: [1, "Operation not permitted"],
      ENOENT: [2, "No such file or directory"],
      EIO: [5, "Input/output error"],
      EBADF: [9, "Bad file number"],
      ENOMEM: [12, "Not enough space"],
      EACCES: [13, "Permission denied"],
      EBUSY: [16, "Device or resource busy"],
      EEXIST: [17, "File exists"],
      ENODEV: [19, "No such device"],
      ENOTDIR: [20, "Not a directory"],
      EISDIR: [21, "Is a directory"],
      EINVAL: [22, "Invalid argument"],
      EMFILE: [24, "Too many open files"],
      ENOSPC: [28, "No space left on device"],
      ENOSYS: [88, "Function not implemented"],
      ESTALE: [133, "Stale file handle"],
      ENOTSUP: [134, "Not supported"],
      ECANCELED: [140, "Operation cancelled"]
    };
    for (name in ref1) {
      v = ref1[name];
      num = v[0], desc = v[1];
      MESSAGES[num] = name + ": " + desc;
      Object.defineProperty(RemoteError, name, {
        value: num
      });
      Object.defineProperty(RemoteError.prototype, name, {
        value: num
      });
    }


    /**
    @method constructor
      コンストラクタ(エラーオブジェクトを生成)
    @param {Object} obj
      JSON-RPCエラー情報
    @param {number} obj.code
      エラー番号
    @param {string} [obj.message]
      エラーメッセージ(未指定の場合、エラー番号から自動推測)
    @param {Object} [obj.data]
      エラーデータ
     */

    function RemoteError(obj) {
      if (typeof obj === "number") {
        obj = {
          code: obj
        };
      }
      this.code = obj.code, this.message = obj.message, this.data = obj.data;
      if (this.message == null) {
        this.message = MESSAGES[this.code];
      }
      Object.freeze(this.data);
      Error.captureStackTrace(this, this.constructor);
      this.name = this.constructor.name;
      return;
    }

    return RemoteError;

  })(Error);


  /**
  @class Canarium.RpcClient
    PERIDOTボードRPCクライアントクラス
  @uses Canarium.AvmTransactions
  @uses Canarium.RemoteError
   */

  Canarium.RpcClient = (function() {
    null;

    /**
    @static
    @property {number}
      デバッグ出力の細かさ(0で出力無し)
     */
    var BSON, JSONRPC_VERSION, MAX_POLLING_INTERVAL_MS, MIN_POLLING_INTERVAL_MS, PERIDOT_RPCSRV_IF_VER, SWI_REG_MSG, SWI_REG_SWI, bson;

    RpcClient.verbosity = 0;


    /**
    @private
    @property {Object[]} _pendingCalls
      リクエスト送信待ち行列(callの要求順にキューされる)
     */


    /**
    @private
    @property {Object} _ongoingCalls
      応答待ちのcall情報(各callのタグをキーとした連想配列)
     */


    /**
    @private
    @property {number} _timerId
      ポーリング用タイマーのID (タイマー無効時はnull)
     */


    /**
    @private
    @property {number} _timerInterval
      ポーリング用タイマーの周期(ms) (タイマー無効時はnull)
     */

    BSON = require("bson").BSON;

    bson = new BSON();

    SWI_REG_MSG = 6;

    SWI_REG_SWI = 7;

    PERIDOT_RPCSRV_IF_VER = 0x0101;

    JSONRPC_VERSION = "2.0";

    MIN_POLLING_INTERVAL_MS = 50;

    MAX_POLLING_INTERVAL_MS = 1000;


    /**
    @method constructor
      コンストラクタ
    @param {Canarium.AvmTransactions} _avm
      Avalon-MMトランザクション層通信クラスのインスタンス
     */

    function RpcClient(_avm) {
      this._avm = _avm;
      this._pendingCalls = [];
      this._ongoingCalls = {};
      this._lastTag = 0;
      this._timerId = null;
      this._timerInterval = null;
      this._timerHandler = this._poll.bind(this);
      this._srvInfoPtr = null;
      this._hostId = null;
      return;
    }


    /**
    @method
      リモートメソッド呼び出しの実行
    @param {string} method
      メソッド名
    @param {Object/function(number)} params
      パラメータ、またはパラメータを返す関数
    @param {number} [interval]
      ポーリング周期(ms)
    @return {Promise}
      Promiseオブジェクト
      (エラー発生時はCanarium.RemoteErrorオブジェクトをreasonとしてRejectされる)
    @return {Object} return.PromiseValue
      返却データ
     */

    RpcClient.prototype.doCall = function(method, params, interval) {
      if (interval == null) {
        interval = MAX_POLLING_INTERVAL_MS;
      }
      return new Promise((function(_this) {
        return function(resolve, reject) {
          var tag;
          tag = _this._getNewTag();
          _this._pendingCalls.push({
            method: method,
            params: params,
            interval: interval,
            tag: tag,
            resolve: resolve,
            reject: reject
          });
          return _this._updateTimer();
        };
      })(this));
    };


    /**
    @method
      接続のリセット
    @return {Promise}
      Promiseオブジェクト
     */

    RpcClient.prototype.resetConnection = function() {
      var error;
      error = Error("RPC connection has been reset by client");
      this._abortPendingCalls(error);
      this._abortOngoingCalls(error);
      this._srvInfoPtr = null;
      this._hostId = null;
      this._updateTimer();
      return Promise.resolve();
    };


    /**
    @private
    @method
      ポーリング用タイマーの作成/更新を行う
    @return {undefined}
     */

    RpcClient.prototype._updateTimer = function() {
      var call, interval, ref1, ref2;
      interval = (ref1 = (ref2 = this._pendingCalls[0]) != null ? ref2.interval : void 0) != null ? ref1 : 2e308;
      for (call in this._ongoingCalls) {
        interval = Math.min(interval, call.interval);
      }
      interval = Math.max(interval, MIN_POLLING_INTERVAL_MS);
      if (this._timerInterval !== interval) {
        if (this._timerId != null) {
          global.clearInterval(this._timerId);
        }
        this._timerId = null;
        this._timerInterval = null;
        if (interval !== 2e308) {
          this._timerId = global.setInterval(this._timerHandler, interval);
          this._timerInterval = interval;
        }
      }
    };


    /**
    @private
    @method
      リクエスト送信待ちのcallをすべてキャンセルする
    @param {Error} error
      エラーオブジェクト
    @return {undefined}
     */

    RpcClient.prototype._abortPendingCalls = function(error) {
      var call, calls, j, len1;
      calls = this._pendingCalls;
      this._pendingCalls = [];
      for (j = 0, len1 = calls.length; j < len1; j++) {
        call = calls[j];
        call.reject(error);
      }
    };


    /**
    @private
    @method
      応答受信待ちのcallをすべてキャンセルする
    @param {Error} error
      エラーオブジェクト
    @return {undefined}
     */

    RpcClient.prototype._abortOngoingCalls = function(error) {
      var call, calls, tag;
      calls = this._ongoingCalls;
      this._ongoingCalls = {};
      for (tag in calls) {
        call = calls[tag];
        call.reject(error);
      }
    };


    /**
    @private
    @method
      ポーリングによるリクエストの送信＆応答受信処理(タイマーハンドラ)
    @return {undefined}
     */

    RpcClient.prototype._poll = function() {
      var raiseIrq, ref1, ref2, reqLen, reqPtr, resLen, resPtr, serverReady;
      if (this._pollingBarrier) {
        return;
      }
      this._pollingBarrier = true;
      reqLen = null;
      reqPtr = null;
      resLen = null;
      resPtr = null;
      serverReady = false;
      raiseIrq = false;
      raiseIrq = true;
      (ref1 = (ref2 = Promise.resolve().then((function(_this) {
        return function() {
          if (_this._srvInfoPtr == null) {
            return;
          }
          return _this._avm.read(_this._srvInfoPtr + 4, 6 * 4).then(function(ab) {
            var id0, id1, ref3;
            ref3 = new Uint32Array(ab), id0 = ref3[0], id1 = ref3[1], reqLen = ref3[2], reqPtr = ref3[3], resLen = ref3[4], resPtr = ref3[5];
            if ((id0 !== _this._hostId[0]) || (id1 !== _this._hostId[1])) {
              return Promise.reject(Error("RPC server has been reset (Host ID does not match)"));
            }
            return serverReady = true;
          });
        };
      })(this))["catch"]((function(_this) {
        return function(error) {
          _this._abortPendingCalls(error);
          _this._abortOngoingCalls(error);
          serverReady = false;
        };
      })(this)).then((function(_this) {
        return function() {
          if (serverReady) {
            return;
          }
          _this._srvInfoPtr = null;
          return _this._avm.iord(_this._avm.swiBase, SWI_REG_MSG).then(function(value) {
            var error;
            if (value === 0) {
              error = new Canarium.RemoteError(Canarium.RemoteError.ECANCELED);
              _this._abortOngoingCalls(error);
              return Promise.reject(error);
            }
            _this._srvInfoPtr = value;
            return _this._avm.read(_this._srvInfoPtr, 7 * 4);
          }).then(function(ab) {
            var error, id0, id1, if_ver, newId, ref3;
            ref3 = new Uint32Array(ab), if_ver = ref3[0], id0 = ref3[1], id1 = ref3[2], reqLen = ref3[3], reqPtr = ref3[4], resLen = ref3[5], resPtr = ref3[6];
            if ((if_ver & 0xffff) !== PERIDOT_RPCSRV_IF_VER) {
              error = new Error("Unsupported remote version");
              _this._abortPendingCalls(error);
              _this._abortOngoingCalls(error);
              return Promise.reject(error);
            }
            newId = Date.now();
            _this._hostId = new Uint32Array(2);
            _this._hostId[0] = newId & 0xffffffff;
            _this._hostId[1] = newId >>> 32;
            return _this._avm.write(_this._srvInfoPtr + 4, _this._hostId.buffer);
          }).then(function() {
            return serverReady = true;
          });
        };
      })(this)).then((function(_this) {
        return function() {
          var call;
          if (_this._pendingCalls.length === 0) {
            return;
          }
          call = null;
          return Promise.resolve().then(function() {
            return _this._avm.iord(reqPtr, 0);
          }).then(function(size) {
            if (size === 0) {
              return;
            }
            raiseIrq = true;
            return Promise.reject();
          }).then(function() {
            var a, bsonData, i, j, obj, params, r, ref3;
            call = _this._pendingCalls.shift();
            params = call.params;
            obj = {
              jsonrpc: JSONRPC_VERSION,
              method: call.method.toString(),
              params: params,
              id: call.tag
            };
            if (typeof params === "function") {
              obj.params = null;
            }
            bsonData = bson.serialize(obj);
            if (typeof params === "function") {
              obj.params = params(reqLen - bsonData.byteLength);
              bsonData = bson.serialize(obj);
            }
            switch (Object.prototype.toString.call(obj.params)) {
              case "[object Object]":
              case "[object Array]":
                null;
                break;
              default:
                return Promise.reject(TypeError("Invalid parameter type"));
            }
            if (bsonData.byteLength > reqLen) {
              return Promise.reject(Error("Request data is too large"));
            }
            a = new Uint8Array(bsonData);
            r = "Request (0x" + (a.byteLength.toString(16)) + " bytes)";
            for (i = j = 0, ref3 = a.byteLength; j < ref3; i = j += 1) {
              if ((i % 16) === 0) {
                r += "\n" + ("0000" + (i.toString(16))).substr(-5) + ":";
              }
              r += " " + ("0" + (a[i].toString(16))).substr(-2);
            }
            console.log(r);
            return _this._avm.write(reqPtr + 4, bsonData.slice(4)).then(function() {
              return _this._avm.write(reqPtr, bsonData.slice(0, 4));
            });
          }).then(function() {
            _this._ongoingCalls[call.tag.toNumber()] = call;
            raiseIrq = true;
          })["catch"](function(error) {
            if (call != null) {
              call.reject(error);
            }
          });
        };
      })(this)).then((function(_this) {
        return function() {
          return Promise.resolve().then(function() {
            return _this._avm.iord(resPtr, 0);
          }).then(function(size) {
            if (size === 0) {
              raiseIrq = true;
              return Promise.reject();
            }
            if (size > resLen) {
              return Promise.reject(Error("Invalid response length"));
            }
            return _this._avm.read(resPtr, size);
          }).then(function(ab) {
            var a, i, j, r, ref3;
            a = new Uint8Array(ab);
            r = "Response (0x" + (a.byteLength.toString(16)) + " bytes)";
            for (i = j = 0, ref3 = a.byteLength; j < ref3; i = j += 1) {
              if ((i % 16) === 0) {
                r += "\n" + ("0000" + (i.toString(16))).substr(-5) + ":";
              }
              r += " " + ("0" + (a[i].toString(16))).substr(-2);
            }
            console.log(r);
            return bson.deserialize(Buffer.from(ab));
          }).then(function(obj) {
            var call, ref3, tag;
            if (obj.jsonrpc !== JSONRPC_VERSION) {
              return Promise.reject(Error("Invalid JSONRPC response"));
            }
            tag = (ref3 = obj.id) != null ? ref3.toNumber() : void 0;
            if (tag == null) {
              return Promise.reject(Error("No valid id"));
            }
            call = _this._ongoingCalls[tag];
            if (call == null) {
              return Promise.reject(Error("No RPC request tagged #" + tag));
            }
            delete _this._ongoingCalls[tag];
            _this._updateTimer();
            if (obj.error != null) {
              call.reject(new Canarium.RemoteError(obj.error));
            } else {
              call.resolve(obj.result);
            }
            return true;
          })["catch"](function(error) {
            if (error == null) {
              return false;
            }
            _this._log(0, "_poll", "receiving response: (" + error.name + ") " + error.message);
            return true;
          }).then(function(clearResponse) {
            return _this._avm.iowr(resPtr, 0, 0);
          }).then(function() {
            return raiseIrq = true;
          })["catch"](function(error) {
            _this._log(0, "_poll", "deleting response: (" + error.name + ") " + error.message);
          });
        };
      })(this))).then.apply(ref2, finallyPromise((function(_this) {
        return function() {
          if (!raiseIrq) {
            return;
          }
          return _this._avm.iowr(_this._avm.swiBase, SWI_REG_SWI, 1);
        };
      })(this)))["catch"]((function(_this) {
        return function(error) {
          return _this._log(0, "_poll", "(" + error.name + ") " + error.message);
        };
      })(this))).then.apply(ref1, finallyPromise((function(_this) {
        return function() {
          return _this._pollingBarrier = false;
        };
      })(this)));
    };


    /**
    @private
    @method
      新しいタグ値の取得
     */

    RpcClient.prototype._getNewTag = function() {
      var value;
      value = Date.now();
      if (value <= this._lastTag) {
        value = this._lastTag + 1;
      }
      this._lastTag = value;
      return BSON.Timestamp.fromNumber(value);
    };


    /**
    @private
    @method
      ログの出力
    @param {number} lvl
      詳細度(0で常に出力。値が大きいほど詳細なメッセージを指す)
    @param {string} func
      関数名
    @param {string} msg
      メッセージ
    @param {Object} [data]
      任意のデータ
    @return {undefined}
     */

    RpcClient.prototype._log = function(lvl, func, msg, data) {
      if (this.constructor.verbosity >= lvl) {
        Canarium._log("RpcClient", func, msg, data);
      }
    };

    return RpcClient;

  })();


  /**
  @class Canarium.RemoteFile
    PERIDOTボード側ファイル操作クラス
  @uses Canarium.RpcClient
  @uses Canarium.RemoteError
   */

  Canarium.RemoteFile = (function() {
    null;

    /**
    @property base
    @inheritdoc Canarium.BaseComm
     */
    var REMOTEFILE_DEFAULT_INTERVAL, j, len1, name, obj, ref1, ref2, value;

    RemoteFile.property("base", {
      get: function() {
        return this._rpcClient.base;
      }
    });


    /**
    @property vfd
      仮想ファイルディスクリプタ
    @readonly
     */

    RemoteFile.property("vfd", {
      get: function() {
        return this._vfd;
      }
    });


    /**
    @static
    @property {number}
      デバッグ出力の細かさ(0で出力無し)
     */

    RemoteFile.verbosity = 0;

    ref1 = {
      O_RDONLY: 0,
      O_WRONLY: 1,
      O_RDWR: 2,
      O_APPEND: 0x0008,
      O_CREAT: 0x0200,
      O_TRUNC: 0x0400,
      O_NONBLOCK: 0x4000
    };
    for (name in ref1) {
      value = ref1[name];
      ref2 = [RemoteFile, RemoteFile.prototype];
      for (j = 0, len1 = ref2.length; j < len1; j++) {
        obj = ref2[j];
        Object.defineProperty(obj, name, {
          value: value
        });
      }
    }


    /**
    @private
    @property {Canarium.RpcClient} _rpcClient
      RPCクライアントクラスのインスタンス
     */


    /**
    @private
    @cfg {number} REMOTEFILE_DEFAULT_INTERVAL
      RPCポーリング周期のデフォルト値
     */

    REMOTEFILE_DEFAULT_INTERVAL = 200;


    /**
    @static
    @method
      RPCによるopenの呼び出し
    @param {Canarium.RpcClient} rpcClient
      RPCクライアントクラスのインスタンス
    @param {string} path
      パス
    @param {number/Object} flags
      フラグ(数字指定またはECMAオブジェクト指定)
    @param {boolean} flags.O_WRONLY
      書き込み専用
    @param {boolean} flags.O_RDONLY
      読み込み専用
    @param {boolean} flags.O_RDWR
      読み書き両用
    @param {boolean} flags.O_APPEND
      追記モード
    @param {boolean} flags.O_CREAT
      作成モード
    @param {boolean} flags.O_NONBLOCK
      非ブロッキングモード
    @param {boolean} flags.O_TRUNC
      切り詰め(truncate)モード
    @param {number} [mode=0777]
      ファイル作成時のパーミッション
    @param {number} [interval=REMOTEFILE_DEFAULT_INTERVAL]
      RPCポーリング周期
    @return {Promise}
      Promiseオブジェクト
    @return {Canarium.RemoteFile} return.PromiseValue
      ファイル操作クラスのインスタンス
     */

    RemoteFile.open = function(rpcClient, path, flags, mode, interval) {
      var n;
      if (mode == null) {
        mode = 0x1ff;
      }
      if (interval == null) {
        interval = REMOTEFILE_DEFAULT_INTERVAL;
      }
      if (Object.prototype.toString.call(path) !== "[object String]") {
        return Promise.reject(TypeError("path must be a string"));
      }
      if (flags == null) {
        return Promise.reject(TypeError("flags must be a number or Object"));
      }
      if (typeof mode !== "number") {
        return Promise.reject(TypeError("mode must be a number"));
      }
      if (typeof flags !== "number") {
        n = this.O_RDONLY;
        if (flags.O_WRONLY) {
          n = this.O_WRONLY;
        }
        if (flags.O_RDWR) {
          n = this.O_RDWR;
        }
        if (flags.O_APPEND) {
          n |= this.O_APPEND;
        }
        if (flags.O_CREAT) {
          n |= this.O_CREAT;
        }
        if (flags.O_NONBLOCK) {
          n |= this.O_NONBLOCK;
        }
        if (flags.O_TRUNC) {
          n |= this.O_TRUNK;
        }
        flags = n;
      }
      return Promise.resolve().then((function(_this) {
        return function() {
          return rpcClient.doCall("fs.open", {
            path: path,
            flags: flags,
            mode: mode
          }, interval);
        };
      })(this)).then((function(_this) {
        return function(result) {
          return new _this(rpcClient, result.fd);
        };
      })(this));
    };


    /**
    @method
      ファイルを閉じる(closeのリモート呼び出し)
    @return {Promise}
      Promiseオブジェクト
    @return {undefined} return.PromiseValue
     */

    RemoteFile.prototype.close = function() {
      if (this._fd == null) {
        return Promise.reject(Error("File not opened"));
      }
      return Promise.resolve().then((function(_this) {
        return function() {
          return _this._rpcClient.doCall("fs.close", {
            fd: _this._fd
          });
        };
      })(this)).then((function(_this) {
        return function() {
          _this._fd = null;
        };
      })(this));
    };


    /**
    @method
      ファイルからデータを読み込む
    @param {number} length
      読み込むバイト数
    @param {boolean} [autoContinue=false]
      読み込んだバイト数がlengthに達するまで繰り返すか否か
    @return {Promise}
      Promiseオブジェクト
    @return {ArrayBuffer} return.PromiseValue
      読み込んだデータ(サイズはlength以下)
     */

    RemoteFile.prototype.read = function(length, autoContinue) {
      var buffers, readNext, total_read;
      if (autoContinue == null) {
        autoContinue = false;
      }
      if (typeof length !== "number") {
        return Promise.reject(TypeError("length must be a number"));
      }
      buffers = [];
      total_read = 0;
      readNext = (function(_this) {
        return function() {
          if (_this._fd == null) {
            return Promise.reject(Error("File not opened"));
          }
          return Promise.resolve().then(function() {
            return _this._rpcClient.doCall("fs.read", {
              fd: _this._fd,
              length: length
            });
          })["catch"](function(error) {
            if (error instanceof Canarium.RemoteError) {
              if (error.code === Canarium.RemoteError.EAGAIN) {
                if (total_read > 0) {
                  return {
                    length: 0
                  };
                }
              }
            }
            return Promise.reject(error);
          }).then(function(result) {
            var read_length;
            read_length = result.length;
            if (read_length > 0) {
              buffers.push(Buffer.from(result.data.read(0, read_length)));
              total_read += read_length;
              length -= read_length;
            }
            if (length <= 0) {
              return;
            }
            if (autoContinue) {
              return readNext();
            }
          });
        };
      })(this);
      return readNext().then((function(_this) {
        return function() {
          var buffer, combined, l, len2, offset, part;
          buffer = new ArrayBuffer(total_read);
          combined = Buffer.from(buffer);
          offset = 0;
          for (l = 0, len2 = buffers.length; l < len2; l++) {
            part = buffers[l];
            part.copy(combined, offset);
            offset += part.length;
          }
          return buffer;
        };
      })(this));
    };


    /**
    @method
      ファイルにデータを書き込む
    @param {ArrayBuffer} data
      書き込むデータ
    @param {boolean} [autoContinue=false]
      書き込んだバイト数がlengthに達するまで繰り返すか否か
    @return {Promise}
      Promiseオブジェクト
    @return {number} return.PromiseValue
      書き込まれたバイト数
     */

    RemoteFile.prototype.write = function(data, autoContinue) {
      var total_written, writeNext;
      if (autoContinue == null) {
        autoContinue = false;
      }
      if (!(data instanceof ArrayBuffer)) {
        return Promise.reject(TypeError("data must be an ArrayBuffer"));
      }
      total_written = 0;
      writeNext = (function(_this) {
        return function() {
          if (_this._fd == null) {
            return Promise.reject(Error("File not opened"));
          }
          return Promise.resolve().then(function() {
            return _this._rpcClient.doCall("fs.write", {
              fd: _this._fd,
              data: Buffer.from(data, total_written)
            });
          })["catch"](function(error) {
            if (error instanceof Canarium.RemoteError) {
              if (error.code === Canarium.RemoteError.EAGAIN) {
                if (total_written > 0) {
                  return {
                    length: 0
                  };
                }
              }
            }
            return Promise.reject(error);
          }).then(function(result) {
            total_written += result.length;
            if (total_written >= data.byteLength) {
              return;
            }
            if (autoContinue) {
              return writeNext();
            }
          });
        };
      })(this);
      return writeNext().then((function(_this) {
        return function() {
          return total_written;
        };
      })(this));
    };


    /**
    @method
      ファイルポインタの移動
    @param {number} offset
      移動量
    @param {number/Object} whence
      移動の基点を示す値(SEEK_SET=0,SEEK_CUR=1,SEEK_END=2)またはECMAオブジェクト
    @param {boolean} whence.SEEK_SET
      先頭から数える
    @param {boolean} whence.SEEK_CUR
      現在位置から数える
    @param {boolean} whence.SEEK_END
      末尾から数える
    @return {Promise}
      Promiseオブジェクト
    @return {number} return.PromiseValue
      移動後のファイルポインタ
     */

    RemoteFile.prototype.lseek = function(offset, whence) {
      if (typeof offset !== "number") {
        return Promise.reject(TypeError("offset must be a number"));
      }
      if (whence != null) {
        if (whence.SEEK_SET && !whence.SEEK_CUR && !whence.SEEK_END) {
          whence = 0;
        }
        if (!whence.SEEK_SET && whence.SEEK_CUR && !whence.SEEK_END) {
          whence = 1;
        }
        if (!whence.SEEK_SET && !whence.SEEK_CUR && whence.SEEK_END) {
          whence = 2;
        }
      }
      if (typeof whence !== "number") {
        return Promise.reject(TypeError("whence must be a number or object with SEEK_xxx key"));
      }
      return this._rpcClient.doCall("fs.lseek", {
        fd: this._fd,
        offset: offset,
        whence: whence
      }).then((function(_this) {
        return function(result) {
          return result.offset;
        };
      })(this));
    };

    RemoteFile.prototype.fstat = function() {
      return Promise.reject(Error("Not implemented"));
    };

    RemoteFile.prototype.ioctl = function() {
      return Promise.reject(Error("Not implemented"));
    };


    /**
    @private
    @method constructor
      コンストラクタ
    @param {Canarium.RpcClient} _rpcClient
      RPCクライアントクラスのインスタンス
    @param {number} _fd
      ファイルディスクリプタ
     */

    function RemoteFile(_rpcClient, _fd) {
      this._rpcClient = _rpcClient;
      this._fd = _fd;
      return;
    }


    /**
    @private
    @method
      ログの出力
    @param {number} lvl
      詳細度(0で常に出力。値が大きいほど詳細なメッセージを指す)
    @param {string} func
      関数名
    @param {string} msg
      メッセージ
    @param {Object} [data]
      任意のデータ
    @return {undefined}
     */

    RemoteFile.prototype._log = function(lvl, func, msg, data) {
      if (this.constructor.verbosity >= lvl) {
        Canarium._log("RemoteFile", func, msg, data);
      }
    };

    return RemoteFile;

  })();


  /*
  canarium.jsの末端に配置されるスクリプト。
  ロードの最終処理や後始末などを記述する。
   */

  if (oldProperty != null) {
    Function.prototype.property = oldProperty;
  } else {
    delete Function.prototype.property;
  }

  this.Canarium = Canarium;

}).call(this);
